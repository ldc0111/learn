### 数据结构

1. **船长语录**：

   在所以算法种类中，跟位运算相关的算法理解难度是最高的；

   面对一个问题的时候，不能靠猜，要靠推理；

   数据结构可以将你锻炼成像计算机一样去思考问题；

   算法中有数据结构，数据结构中有算法，两者分不开；

   数据结构分两个层面：逻辑 + 物理；

2. 数据结构 = 结构定义 + 结构操作；

3. **顺序表**

4. **链表**

   - 每一个链表中的元素都得可以被一个小抓手索引到；
   - 两种操作：插入 + 删除
   - 单向循环链表：把`head`看做是整个单向循环链表的尾节点；

5. **队列**

   - 队列－－假溢出＝＝>循环队列；
   - *单调队列* 的本质作用：维护滑动窗口内部的最值，这个区间也可以是变长区间；
   - 单调递减队列：维护区间最大值；
   - 单调递增队列：维护区间最小值；
   - **单调队列应用举例**：
     - *问题描述*：在一个无序数组（无重复元素）中，找出连续的`5`个数，这`5`个数排完序之后是连续的`5`个数（顺子）；
     - *解决方案*：通过分析，我们可以得出这`5`个数有一个性质，就是最大值与最小值的差是`4`。我们可以将每五个数看做一组，找出这五个数当中的最大值和最小值，若差值为`4`，则代表我们找到了，可以借助滑动窗口来实现。找五个数中的最大值和最小值，若通过普通的比较查找，则需要比较`10`次，最终解决这个问题的时间复杂度是`O(10n)`；我们可以通过单调队列来维护这五个数的最大值和最小值，利用单调递减队列维护最大值，用单调递增队列维护最小值，这种方法中每一个元素最多进队列`1`次、出队列`1`次，两个队列，再乘以`2`，故这样解决问题的时间复杂度是`O(4n)`；下面我们介绍一种时间复杂度为`O(n)`的解法。
     - *BOSS*：我们知道，连续的`5`个数（顺子）排列组合的话也只有`120`种情况，我们可以将所有的情况列举出来，计算相邻两个数的差，也只有`120`种情况，将这些情况记录下来。然后我们扫描元素的时候（`5`个为一组），只需要计算相邻元素的差，并与我们记录的情况作对比就行了。接下来要解决记录与对比的问题，我们知道上面提到的差的范围为`[-4,4]`，我们为其加上`5`，变成`[0,9]`，也就是每两个数的差可以用`0~9`之间的一个数表示，一共有`4`个差，也就是一个`4`位数就可以表示一种情况，我们只需要开一个`10000`的数组来记录就行了，这时对比的时间复杂度就是`O(1)`。这样，我们解决这个问题的时间复杂度就是`O(n)`了。
     - *补充*：对于上述的*BOSS* 解法，如果是要找连续的`7`个数，则差的范围会变成`[-6,6]`，我们为其加上`7`，变成`[0,13]`，这时差的范围就大于`10`了，即每一位数字就大于`10`了，上述算法看似就不行了，不过别忘了我们并不是只能用十进制来表示一个数，这里我们可以用十四进制来表示每一个数，那么接下来的解法就类似了。当待求的连续的数的个数改变之后，只需换个进制来表示两个元素的差就行了。不过当待求的连续的数的个数太多时，我们就无法一一列举所有的情况了，这个算法就不适用了，就得退化到上述利用单调队列的解法，单调队列的解法是通用的。

6. **栈**

   - 典型问题＝＝>括号匹配：括号之间的嵌套相当于事件的包含关系；
   - 栈的本质：可以处理具有完全包含关系的问题；

7. **树与二叉树**

   - 树的层次结构与人的思维方式类似；
   - 树的节点代表集合，树的边代表关系；
   - 链表是特殊的树形结构（一叉树）；
   - 二叉树中度为`０`的节点比度为`２`的节点多`１`个；
   - 二叉树的遍历：前序＝＝>根－>左－>右；中序＝＝>左－>根－>右；后序＝＝>左－>右－>根；
   - 算法优化手段：*记录式改计算式*；（完全二叉树－－>数组存储）；
   - **二叉树的广义表表示**：利用栈，左括号代表入栈，右括号代表出栈；以逗号分割，逗号左边的加在左子树，逗号右边的加在右子树；
   - **哈弗曼编码**：最短带权路径；

8. **堆与优先队列**

   - **堆**：本质上是一棵完全二叉树，可以用连续的数组空间存储；
   - **大顶堆**（堆顶元素为最大值）＆**小顶堆**（堆顶元素为最小值）；
   - 插入元素：从堆尾插入，依次调整堆元素；
   - 删除元素：从堆顶弹出，将最后一个元素放在第一个出堆元素的位置，调整堆元素；
   - *堆排序*；
   - **堆应用举例**：
     - *问题描述*：从`1`亿个数中找出最小的十个数；
     - *解决方案*：我们要从许多数中找出最小的十个数，可以通过维护一个元素个数为`10`的大顶堆来实现。这个大顶堆中，堆首元素是这十个元素中最大的，即这个大顶堆中的十个元素是目前最小的十个元素；然后依次扫描所有的元素，如果扫描到的元素比堆顶元素小，则替换进来，再维护一下堆，继续扫描，直到扫描完所有的元素。这时堆中剩余的十个元素即为最小的十个数。

9. **一个简单的开脑洞的问题**

   - **船长提的小问题**：
     - *问题描述*：你手里有两个手机，现在要你测出对于一个`100`层的高楼，手机最低在哪一层楼掉下会摔碎，最多最少测几次，即手机在`x-1`层掉下不会摔碎，在`x`层掉下会摔碎，那么这个`x`便是我们要找的。
     - *错误解法*：二分法。由于我们手机数量有限，得有手机才能测试，如果手机都摔碎了就无法测试了，所以这个方法不可行。
     - *解决方案*：首先我们来定义两个函数，`F(n)`代表测`n`层最多最少需要测几次；`F(x,n)`代表共需测到`n`层，第一次测第`x`层，最多最少需测几次；不难得出`F(n)`与`F(x,n)`的答案是相同的，即`F(100)=F(x,100)`，其中`F(100)`为我们的待求值。接下来我们来求这个函数的表达式，不难得出`F(x,n)=max(x,1+F(100-x))`，这是因为我们第一次测了`x`层之后，若手机坏了，则需从第`1`层开始，一层一层开始向上测，直到第二个手机也坏了，最坏的情况是测到第`x-1`层，这时共测了`x`次；若手机没坏，则我们继续求`F(100-x)`就行，即从`x+1`层开始测就行，这时`F(x,n)=1+F(100-x)`。由于我们要求最坏情况下测几次，故`F(x,n)`需取那两个值的最大值，而且我们知道`x`越大，`F(100-x)`就越小，故要使`F(x,n)`最小，则需`x`与`F(100-x)`都适中才行，所以我们取`x=1+F(100-x)`处的`x`值。那么下面我们来计算`F(100-x)`，我们知道`F(100-x)=F(x',100-x)`，我们也可以得到`F(x',100-x)=max(x',1+F(100-x-x'))`，与上面的分析一样，当`x'`等于`1+F(100-x-x'))`时才是我们要求的答案，此时有`F(x',100-x)=x'`，即`F(100-x)=x'`，又由于`x=1+F(100-x)`，所以我们可以得到`x'+1=x`，即第二次测的楼层数要比第一次的少一。有了上面这个结论就可以推导我们的公式了。我们不妨设共测了`n`次，最后一次肯定是测一层的，则共测了`1+2+3+...+n`层，即`n*(n+1)/2`层，我们需要这个值大于`100`，即`n*(n+1)/2 > 100`，求解得出`n`的最小值是`14`，这就是我们要求的答案，即最多最少测`14`次。
