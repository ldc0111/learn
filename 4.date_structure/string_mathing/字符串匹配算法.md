#### BF暴力匹配算法

有文本串和模式串

当文本串和模式串在某个位置失配时，

就从文本串当前与模式串匹配的第一个字符的下一个开始匹配

非常ｅａｓｙ

时间复杂度ｎ×ｍ

编写代码的时候注意ｔｅｘｔ的下标最大到ｌｅｎ１　－　ｌｅｎ２,

len1位文本串长度，ｌｅｎ２位模式串长度

返回ｉ是第一个匹配到的字符的位置

####　KMP算法

暴力匹配算法的改进版本，通过模式串的特殊回溯，避免文本串的回溯

需要特殊处理一个next数组，含义为以i为止的字符的后缀与本字符串前缀匹配的最大长度

理解难点是多次回溯：当以第i个的字符串后缀与i-1匹配的最长前缀的后一个字符不同时，就回溯以i-1的最长前缀为的最后一个字符为止j，找到以j为止的最长后缀匹配最长前缀，看这个最长前缀的后一个字符是不是等于i，如果不等重复以上操作，直到第一个字符为止

算法难点：自我匹配，回溯(展开)

返回ｉ是最后一个匹配到的字符的位置



![](/home/tesla/github/learn/4.date_structure/string_mathing/IMG_20181230_154202.jpg)

####　SUNDAY算法

传说是在星期天没事干，为了完成任务想出来的算法，必要条件推导

有一个对每个字符的标记位，标记着最后一个出现这个字符的位置到结束位置的距离

当存在模式串中不存在的字符的时候直接跳过一个len长度的串，因为个匹配失败之后，再次匹配，匹配位置一点在ｉ＋ｌｅｎ之后或等一ｉ＋ｌｅｎ

标记数组的作用当失配的时候用来对齐失配位置文本串与模式串的字符。



返回ｉ是第一个匹配到的字符的位置

##### 正确性分析，

当字符串失配的时候，能够匹配模式串的文本串一定在i+len之后，如果模式串中存在失配字符，当我们记录的是与失配字符相等的最后一个字符出现的位置时，向后移动的范围是最小的，一定不会错过正确答案

#### shift-and算法

应用场景：用来进行多模匹配，且模式串不太长的情况

位并行方法

有一个位标记数组，每一个整形代表一种字符，整形的值用二进制表示就是响应字符在模式串中出现的位置

当p变量的第i位出现值的时候表示，从0到i的值都被匹配成功，当p的低len-1位匹配成功时表示模式串匹配成功

状态转移，暂时只考虑每个字符出现一次的情况，

当上一次第i位匹配成功的时候，文本串向后移动一位，

这时当文本串的字符是模式串的字符的时候，p的第i位的标记应该向后移动一位与标记数组（因为标记数组存放的是相应字符在模式串中相应位置的信息，所以p的上一位匹配成功后，应该向后移动去匹配匹配下一位）相与表示答案不为0，表示匹配成功

如果当文本串的下一个字符不是模式串的字符的时候，p的第i位向后移动去匹配下一位与标记数组相与就会是0，匹配失败，重新开始

如果存在重复字符的时候就会去匹配多个下一位的值，会保留所有匹配到的正确的值，因为我们只看最高位，所以只要最高位匹配成功即可



理解难点：抽象程度过高，状态转移



返回ｉ是最后一个匹配到的字符的位置

整理成状态码之后就跟之前的字符串没有关系了，所以可以进行多模匹配



#### 字典树

字典树没什么难点，	就是拥有26个叶子节点的树而已

#### 双数组字典树

双数组字典树就是把字典树的的信心改变一种存储方式，更加高效的利用空间



#### AC自动机

这个就比较吊了，简直炸天，

用途进行多个字符串的匹配时，进行加速

失败指针的含义：当这个节点对儿子节点匹配失败之后，就去寻找以以这个儿子节点为止的后缀为前缀的字符串，（跟节点没有失败指针，根节点的儿子节点的失败指针是根节点）



建立：

先把多个字符串建立一颗字典树，(字典树节点增加信息：失败指针，)

失败指针的含义当一个字符串匹配失败时，就找到以这字母为止的最长后缀与另一个单词的前缀相等的状态继续匹配另一个单词

查找：

https://www.cnblogs.com/cmmdc/p/7337611.html

与kmp相同，母串不回溯，只在字典树上跳跃， 当匹配成功时，节点下移，并遍历器失败指针，看以这个节点位后缀的，某个前缀是否存在一个完整的单词，当匹配失败时，就去遍历这个节点的失败指针，看是否有以这个节点为止的字符后缀为前缀且有这个孩子节点的分支

如果没有就去迭代遍历，直到到一个以这个字符后桌为前缀的单词(注意每次迭代，后缀与前缀相同的长度就越小，直到为0)，或者到跟节点



理解难点：状态转化，有限状态机；