### c++对象模型



### lama表达式

[](){}



### new深ｃｏｐｙ问题

1. new一个变量
2. new数组
3. new原地构造



### 返回值优化

```c
vector<int> func() {
      vector<int> temp;
      temp[4] = 5678;
      return temp;
}


vector<int> func(vector<int> *p = nullptr) {
      vector<int> temp;
      temp[4] = 5678;
      return temp;
}
```

func有一个默认参数,当是一个指针 验证输出temp和返回值的地址应该是一样的

右值判断：

这条语句执行结束之后我们能不能访问这个变量



### 普通的函数是跟着类走的，虚函数是跟着对象走的

虚函数为什么是跟着对象走的

身份证

对象的头部有一个地址，指向一个空间，空间内是各个虚函数



### this是一个变量 构造函数有参数是一个地址

1. 

```c
        class A{
            public:
            virtual void test(int x) {
                cout <<  "bye bye" << endl;
            }
        };
        class B: public A{
            public:
            virtual void test(int x) {
                cout << "my name is b" << endl;
                cout  << x << endl;
            }
        };
        typedef void (*FUNC)(int);
        int test() {
            B b;
            b.test(5);
            ((FUNC**)(&b))[0][0](5);
            return 0;
        }
```

2. 

```c
        class A{
            public:
            virtual void test(int x) {
                cout <<  "bye bye" << endl;
            }
        };
        class B: public A{
            public:
            virtual void test(int x) {
                cout << "my name is b" << endl;
                cout  << x << endl;
            }
        };
        typedef void (*FUNC)(void *,int);
        int test() {
            B b;
            b.test(5);
            ((FUNC**)(&b))[0][0](&b,5);
            return 0;
        }
```

###　移动构造函数

1.默认

2.有参构造

3.拷贝构造函数

4.移动构造函数（右值引用）

对象存储模型，默认构造函数其实是有参数



### 科目是认为划分出来的，不是知识的本质，关联才是知识的本质



### 右值引用

```c
namespace my1{
    void print(int &a){
        cout << "print left " << a << endl;
    }
    void print(int &&a) {
        cout << "print right " << a << endl;
    }
    void value_type(int &a) {
        cout << "left value " << a << endl;
        print(a);
    }
    void value_type(int &&a) {
        cout << "right value " << a << endl;
        print(a);
        print(std::forward<int &&>(a));//声明位右值
        print(std::move(a));//强制为右值引用
        return ;
    }

    void test() {
        int a = 9973;
        value_type(a);
        value_type(4 + 5);
        string aa = "hello";
        string bb = "world";
        string cc = "!";
        string dd;
        dd = aa + bb + cc;//如果没有右值引用，会声明两个中间变量，有有值引用则不会产生中间变量，会直接移动构造移动构造，减少大量的时间
        return ;
    }
}
/*
left value 9973
print left 9973
right value 9
print left 9
print right 9
print right 9
*/
```

