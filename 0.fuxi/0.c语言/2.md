## 知识专题:

### 操作系统中的程序的内存结构-不太准确－待定中

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153)

一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。

BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。

数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配

代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量

text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。

bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。

data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。

数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。

可执行程序在运行时又多出两个区域：栈区和堆区。

栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。

堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。



### static:

[c语言中](<https://blog.csdn.net/guotianqing/article/details/79828100>)

**静态局部变量**: 使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。

> 变量在全局数据区分配内存空间；编译器自动对其初始化  其作用域为局部作用域，当定义它的函数结束时，其作用域随之结束

**静态全局变量**:仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。

> 在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。

**函数:**函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数。其特性如下：

- 静态函数只能在声明它的文件中可见，其他文件不能引用该函数
- 不同的文件可以使用相同名字的静态函数，互不影响



### struct:

内存对齐和位域

[结构体对齐的原因?（２条）](<http://diheshu.blog.sohu.com/145802264.html>)

**什么是对齐，以及为什么要对齐：**

现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。   

**字节对齐作用和原因：**

对齐的作用和原因：各个硬件平台对存储空间的处理上有 很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种 架构下编程必须保证字节对齐，其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些 平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇 地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据，显然在读取效率上下降很多。

可以通过预编译命令进行调整　

```c++
#progma pack (2) /*指定按2字节对齐*/
#progma pack () /*取消指定对齐，恢复缺省对齐*/
```

[结构体位域](<https://www.cnblogs.com/dolphin0520/archive/2011/10/14/2212590.html>>)

一.使用位段需注意一下几点:

​    1)位段的类型只能是int，unsigned int，signed int三种类型，不能是char型或者浮点型；

​    2)位段占的二进制位数不能超过该基本类型所能表示的最大位数，比如在VC中int是占4个字节，那么最多只能是32位；

​    3)无名位段不能被访问，但是会占据空间；

​    4)不能对位段进行取地址操作；

​    5)若位段占的二进制位数为0，则这个位段必须是无名位段，下一个位段从下一个位段存储单元(这里的位段存储单元经测试在VC环境下是4个字节)开始存放；

​    6)若位段出现在表达式中，则会自动进行整型升级，自动转换为int型或者unsigned int。

​    7)对位段赋值时，最好不要超过位段所能表示的最大范围，否则可能会造成意想不到的结果。

​    8)位段不能出现数组的形式。

二.位段结构在内存中的存储方式

​    对于位段结构，编译器会自动进行存储空间的优化，主要有这几条原则:

   1)如果一个位段存储单元能够存储得下位段结构中的所有成员，那么位段结构中的所有成员只能放在一个位段存储单元中，不能放在两个位段存储单元中；如果一个位段存储单元不能容纳下位段结构中的所有成员，那么从剩余的位段从下一个位段存储单元开始存放。(在VC中位段存储单元的大小是4字节).

   2)如果一个位段结构中只有一个占有0位的无名位段，则只占1或0字节的空间(C语言中是占0字节，而C++中占1字节)；否则其他任何情况下，一个位段结构所占的空间至少是一个位段存储单元的大小；

### enum(枚举):

<https://blog.csdn.net/hellojoy/article/details/79883671>

<http://c.biancheng.net/view/2034.html>

### union:

<http://c.biancheng.net/view/2035.html>

### const:

<http://c.biancheng.net/view/2041.html>

指针常量，常量指针，全局变量和局部变量存储位置，c语言可修改



//c++

### 可变参数:

见c语言第四节变参函数

### c语言函数传参顺序

从右往左

[参考网址](<https://blog.csdn.net/liangkaiming/article/details/6230779>)

[详细参考网址](<https://my.oschina.net/N3verL4nd/blog/866969>)

程序栈底为高地址，栈顶为低地址，因此上面的实例可以说明函数参数入栈顺序的确是从右至左的。可到底为什么呢？查了一直些文献得知，参数入栈顺序是和具体编译器实现相关的。比如，Pascal语言中参数就是从左到右入栈的，有些语言中还可以通过修饰符进行指定，如Visual C++。即然两种方式都可以，为什么Ｃ语言要选择从右至左呢？

进一步发现，Pascal语言不支持可变长参数，而Ｃ语言支持这种特色，正是这个原因使得Ｃ语言函数参数入栈顺序为从右至左。具体原因为：C方式参数入栈顺序（从右至左）的好处就是可以**动态变化参数个数**。通过栈堆分析可知，自左向右的入栈方式，最前面的参数被压在栈底。除非知道参数个数，否则是无法通过栈指针的相对位移求得最左边的参数。这样就变成了左边参数的个数不确定，正好和动态参数个数的方向相反。

因此，Ｃ语言函数参数采用自右向左的入栈顺序，主要原因是为了支持可变长参数形式，C语言中可变参数都是从左到右，所以不管你有多少个参数反正将最右面的那个压入栈底，最左面的参数出入栈顶。换句话说，如果不支持这个特色，Ｃ语言完全和Pascal一样，采用自左向右的参数入栈方式。



### 宏：

<https://blog.csdn.net/jmh1996/article/details/72832737>

### 大端小端判断方式

大端是指低字节存储在高地址；小端存储是指低字节存储在低地址。我们可以根据联合体来判断该系统是大端还是小端。因为联合体变量总是从低地址存储。

```c++
int fun() {
    union test{
        int i;
        char c;
    };
    test t;
    t.i = 1;
    
    //如果是大端则　t.c为0x00,则t.c!= 1,返回0 是小端　则t.c为0x01,则t.c==1,返回１
    return (t.c == 1);
}
```



###　strcpy和strlen实现

strcpy是字符串拷贝函数，原型：

char *strcpy(char* dest, const char *src);

从src逐字节拷贝到dest，直到遇到'\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。
strlen函数是计算字符串长度的函数，返回从开始到'\0'之间的字符个数。

**stacpy的实现**

```c
char * strcpy( char *strDest, const char *strSrc ) 
{
	assert( (strDest != NULL) && (strSrc != NULL) );
 	char *address = strDest; 
 	while( (*strDest++ = *strSrc++) != ‘\0’ ); 
 	return address;
 }
```

//无bug版本

```c++
char * Strcpy(char *strDest, const char *strSrc) {
    assert( (strDest != NULL) && (strSrc) );
    char tmpSrc[strlen(strSrc) + 1];
    int i = 0;
    while( (tmpSrc[i++] = *strSrc++) );
    char *address = strDest;
    i = 0;
    while( (*strDest++ = tmpSrc[i++]) );
    return address;
}
```



**strlen的实现**

```c
/* strlen: return length of s */
int strlen(char s[])
{
	int i;
	while (s[i] != '\0') ++i;
	return i;
}
```



###　i++和++i的区别

1. ++i称先自增，把储存器中i的值增加1，再取出来参与本次运算。
2. i++称后自增，先把储存器中i的值取出来参与本次运算，储存器中i的值再增加1。

**++i的实现**

```c
//c
int pre(int *x){
    *x += 1;
   return *x; 
}
//c++
int&  int::operator++（）{
         *this +=1；
          return *this；
     }
```

**i++的实现**

```c
//c
int nex(int *x) {
    int old = *x;
    *x += 1;
    return old;
}
//c++
const int  int::operator（int）{
     int oldValue = *this；
     ++（*this);
     return oldValue；
     }
```



### include头文件的顺序以及双引号””和尖括号<>的区别？

Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。

双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。



对于使用双引号包含的头文件，查找头文件路径的顺序为：

当前头文件目录

编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）

系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径



对于使用尖括号包含的头文件，查找头文件的路径顺序为：

编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）

系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径