## 递推

####　兔子繁殖问题

##### 题目大意

如果有一对小兔，每一个月都生下一对小兔，而所生下的每一对小兔在出生后的第三个月也都生下一对小兔。那么，由一对兔子开始，n 个月后有多少只小兔子呢？

##### 简单思路

​	简单模拟一下状态１　２　３　５　，

　　这个月兔子的数量等于上个月兔子的数量与，可生产的兔子的数量，最晚达到可以生产的兔子在　２个月前，所以`dp[i] = dp[i - 1] + dp[i - 2]`

##### 优化思路

采用循环数组的方式可以节省空间,而且使用了高精度加法，防止溢出

##### 代码一

````c
/*************************************************************************
	> File Name: 038.cpp
	> Author: ldc
	> Mail: litesla
	> Created Time: 2019年01月11日 星期五 17时12分41秒
 ************************************************************************/

#include<iostream>
#include <cstdio>
using namespace std;
#define maxn 100
int a[2][maxn] = {0};

//1 2 3 5

int main() {
    int n;
    cin >> n;
    a[0][0] = a[1][0] = 1;
    a[0][1] = 1;
    a[1][1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= a[(i - 1) % 2][0]; j++) {
            a[i % 2][j] = a[(i - 1) % 2][j] + a[(i - 2) % 2][j];
        }
        a[i % 2][0] = a[(i - 1) % 2][0];
        for (int k = 1; k <= a[i % 2][0]; k++) {
            if (a[i % 2][k] < 10) continue;
            a[i % 2][k + 1] += a[i % 2][k]/ 10;
            a[i % 2][k] = a[i % 2][k] % 10;
            if(k == a[i % 2][0]) a[i % 2][0]++;
        }
    }
    for (int i = a[n % 2][0]; i >= 1; i--) {
        printf("%d", a[n % 2][i]);
    }
    printf("\n");
    return 0;
}

````



#### 爬楼梯

##### 题目大意

小海是一个顽皮的少年，对于爬楼梯这种事情，他从来都不愿意一步一步走，每次上楼梯的时候，要么往上跨两级，要么往上跨三级。对于有 n 级台阶的楼梯，小海想知道他从最下面走到最上面的方法总数。

##### 简单思路

​	小陶每次怕楼梯的时候要么一次爬２阶，要么３阶，所以定义ｄｐ[i]为上到本台阶一共的方法总数，他就等于`dp[i] = dp[i - 2] + dp[i - 2]`

##### 优化思路

同样因为他只需要４个状态所以他只需要４个元素，同时使用高精度

##### 代码一

````c++
/*************************************************************************
	> File Name: 039.cpp
	> Author: ldc
	> Mail: litesla
	> Created Time: 2019年01月11日 星期五 17时32分58秒
 ************************************************************************/

#include <iostream>
#include <cstdio>
using namespace std;
#define maxn 500
int a[4][maxn] ={0};


int main() {
    int n = 0;
    cin >> n;
    a[0][0] = a[1][0] = a[2][0] = a[3][0] = 1;
    a[0][1] = a[1][1] = 0;
    a[2][1] = a[3][1] = 1;
    for (int i = 4; i <= n; i++) {
        for (int j = 1; j <= a[(i - 1) % 4][0]; j++) {
            a[i % 4][j] = a[(i - 2) % 4][j] + a[(i - 3) % 4][j];
        }
        a[i % 4][0] = a[(i - 1) % 4][0];
        for (int k = 1; k <= a[i % 4][0]; k++) {
            if (a[i % 4][k] < 10) continue;
            a[i % 4][k + 1] += a[i % 4][k] / 10;
            a[i % 4][k] = a[i % 4][k] % 10;
            if (k == a[i % 4][0]) a[i % 4][0]++;
        }
    }
    for (int i = a[n % 4][0]; i >= 1; i--) {
        cout << a[n % 4][i];
    }
    cout << endl;
    return 0;
}

````





#### 墙壁涂色

##### 题目大意

给一个环形的墙壁涂颜色，颜色一共有 k 种，墙壁被竖直地划分成 n 个部分，相邻的部分颜色不能相同。请你写程序计算出一共有多少种给墙壁上色的方案？

例如，当 n=5,k=3n=5,k=3 时，下面是一种合法的涂色方案

##### 简单思路

简单模拟一下dp[n] 位ｎ块墙壁图色的方法总数，dp[n]\[i][j]，表示ｎ块墙壁，第一块涂ｉ色的方法第ｎ块涂ｊ色的方法总数

f[n]\[i][j] = $\sum_{k=0}^n$f[n - 1]\[i][k]  k!= j

##### 优化思路

第一次优化，因为只需要两种状态所以可以运用循环数组，

第二次压缩列出几次f[n]\[i][j]的值，就会发现，每一行只有一个的值跟其他的值不一样，其他的都是重复的，且那个值等于上一次其他相同值的和，相同的值等于上次一相同值的和减去一个在加上一个不同值，所以可以优化掉[i]\[j]两层的值，直接进行计算

##### 代码一：

````c
/*************************************************************************
	> File Name: 041.cpp
	> Author: ldc
	> Mail: litesla
	> Created Time: 2019年01月12日 星期六 17时39分58秒
 ************************************************************************/

#include <iostream>
#include <string>
#include <cstdio>
#include <string.h>
using namespace std;

#define maxn 1000
#define maxk 10
int  dp[2][maxk + 5][maxk + 5][1000] = {0};

void add(int *a, int *b){
    a[0] = a[0] > b[0] ? a[0] : b[0];
    for (int i = 1; i <= a[0]; i++) {
        a[i] += b[i];
    }
    for (int i = 1; i <= a[0]; i++) {
        if(a[i] < 10) continue;
        a[i + 1] += a[i] / 10;
        a[i] %= 10;
        if (i == a[0]) a[0]++;
    }
    return ;
}

void print(int *a) {
    for (int i = a[0]; i >= 1; i--) {
        cout << a[i];
    }
    cout << endl;
}
int main() {
    int wallsize,m;
    int i,j,k,l;
    cin >> wallsize >> m;
    if(wallsize  == 1) {
        cout << m << endl;
        return 0;
    }
    for (i = 0; i < m; i++) {
        for (j = 0; j < m; j++) {
            if (i == j) continue;
            dp[0][i][j][0] = dp[0][i][j][1] = 1;
        }
    }
    for (i = 3; i <= wallsize; i++) {
        for (j = 0; j < m; j++) {
            for (k = 0; k < m; k++) {
                memset(dp[i % 2][k][j], 0, sizeof(dp[i % 2][k][j]));
                //dp[i % 2][k][j][0] = 0;
                for (l = 0; l < m; l++) {
                    if(l == j) continue;//和上一个不能相同//这一个的颜色等于上一个非这个颜色的和
                    add(dp[i % 2][k][j], dp[(i % 2) ^ 1][k][l]);
                    //dp[i % 2][k][j] += dp[(i % 2) ^ 1][k][l];
                }
            }
        }
    }
    int ans[maxn] = {0};
    for (i = 0; i < m; i++) {
        for (j = 0; j < m; j++) {
            if (i == j) continue;
            add(ans,dp[wallsize % 2][i][j]);
        }
    }
    print(ans);
    return 0;
}
````



##### 代码二：

````c
/*************************************************************************
	> File Name: 041a.cpp
	> Author: ldc
	> Mail: litesla
	> Created Time: 2019年01月14日 星期一 10时24分44秒
 ************************************************************************/

#include<iostream>
#include <cstdio>
#include <string.h>
#include <cmath>
using namespace std;

int dp[3][1000];
void add(int *a, int *b, int *c, int x, int y) {
    a[0] = b[0] > c[0] ? b[0] : c[0];
    for (int i = 1; i <= a[0]; i++) {
        a[i] = x * b[i] + y * c[i];
    }
    for (int i = 1; i <= a[0]; i++) {
        if (a[i] < 10) continue;
        a[i + 1] += a[i]/10;
        a[i] %= 10;
        if (i == a[0]) a[0]++;
    }
    return ;
}

void print(int *a) {
    for (int i = a[0]; i >= 1; i--) {
        cout << a[i];
    }
    cout << endl;
}

int main(){
    int w,n,temp;
    cin >> w >> n;
    if (w == 1) {
        cout << n << endl;
        return 0;
    }
    dp[0][1] = dp[0][0] = 0;
    dp[1][1] = dp[1][0] = 0;
    dp[2][1] = (n * n - n);
    //dp[2][1] = 1;
    dp[2][0] = floor(log10(n * n - n)) + 1;

    for (int i = 3; i <= w; i++) {
        memset(dp[i % 3],0,sizeof(dp[i % 3]));
        add(dp[i % 3], dp[(i - 1) % 3],dp[(i - 2) % 3], n - 2, n - 1);
        //dp[i % 3] = (n - 2) * dp[(i - 1) % 3] + (n - 1) * dp[(i - 2) % 3];
        //cout << dp[i% 3] << endl;
    }
    print(dp[w % 3]);
    //cout << dp[w % 3] * (n * n - n) << endl;
    return 0;
}
````



#### 钱币问题

##### 题目大意

某个国家的货币系统中，有 m 种面额的钱币，现在要用这 m 种面额的钱币凑足 n 元钱，问一共有多少种方法。m 种钱币不一定要都被用到。

例如，有 3 种钱币，分别为1、2、5，那么有四种方法拼凑出5元钱

1. `(1，1，1，1，1)` 全是1元钱
2. `(1，2，2)`，`(1，1，1，2)` 使用1元和2元
3. `(5)` 只用5元钱

**注意：**方案中的钱币不分顺序，也就是说`（1，2，2）` 和`（2，1，2）`是同一种方法。

##### 简单思路

##### 优化思路

##### 代码一





## 动态规划

#### 最长上升子序列

##### 题目大意

有一个数字序列，求其中最长严格上升子序列的长度

##### 简单思路

##### 优化思路

##### 代码一



#### 最长公共子序列

##### 题目大意

给出两个字符串，求其两个的最长公共子序列长度。

##### 简单思路

##### 优化思路

##### 代码一



#### 切割回文

##### 题目大意

给出一个字符串S，问对字符串S最少切几刀，使得分成的每一部分都是一个回文串（注意：单一字符是回文串）

##### 简单思路

##### 优化思路

##### 代码一



#### 0/1背包

##### 题目大意

给一个能承重VV的背包，和nn件物品，我们用重量和价值的二元组来表示一个物品，第ii件物品表示为（Vi，Wi）（Vi，Wi），问：在背包不超重的情况下，得到物品的最大价值是多少？

##### 简单思路

##### 优化思路

##### 代码一



#### 完全背包

##### 题目大意

有N种物品和一个容量为 VV 的背包，每种物品都有无限件可用。

第 ii 种物品的体积是CiCi，价值是WiWi。求解在不超过背包容量的情况下，能够获得的最大价值。

##### 简单思路

##### 优化思路

##### 代码一



#### 多重背包

##### 题目大意

给有一个能承重 VV 的背包，和n种物品，每种物品的数量有限多，我们用重量、价值和数量的三元组来表示一个物品，第 ii 件物品表示为（Vi，Wi，Si）（Vi，Wi，Si），问在背包不超重的情况下，得到物品的最大价值是多少？

##### 简单思路

##### 优化思路

##### 代码一



#### 扔鸡蛋

##### 题目大意

##### 简单思路

##### 优化思路

##### 代码一