## 数学期望

### 问题一：

#### 问题描述：

有一个木桶，里面有M个白球，小明每分钟从桶中随机取出一个球涂成红色（无论白或红都涂红）再放回，问小明将桶中球全部涂红的期望时间是多少？

#### 分析过程：
数学期望类的题目，主要是要理解什么是数学期望，数学期望是干什么用的，关于这些问题的解答，大家可以自己去理解，思考或者翻书，我要讲的内容是如何利用这些数学期望的特点。

数学期望的递归特性：

飞行棋大家都玩过吧，应该知道每次抛到6，就有一架飞机可以出门了，那么问你一架飞机可以出门的时候，抛筛子次数的数学期望是多少？

你估计会毫不犹豫的说是6（P=1/6，E=1/P=6），但是你思考过深一层次的原因吗？

好吧，我来告诉你，我们记抛6的期望次数是E，如果第一次抛的是6，那么就是1次，概率是1/6;如果第一次不是6呢，那么次数是1+E，概率为5/6;

那么 E = 1 * (1/6) + (1+E) * (5/6),你可以很容易的解出 E = 6

上面加粗的红色字体用的就是类似一个递归的概念，希望你能理解吧，不行的话，那只能自己去努力理解了，呵呵。

 

现在我们开始解答上面的问题：

令P[i]代表M个球中已经有i个球是红色后，还需要的时间期望，去将所有球都变成红色。

 

So，给出递归式：P[i]= (i/M) * P[i] + (1-i/M)* P[i+1] + 1

我相信大家都能理解这个公式的含义，不过还是解释一下，在P[i]的情况下，我们选一次球，如果是红球，那么概率是i/M，子问题还是P[i]，如果是白球，那么概率是1-i/M，子问题是P[i+1]，注意你当前的选球操作要计算在内，即一次

 

化简如上递归式得：P[i] = P[i+1] + M/(M-i)，显然P[M] = 0;

所以：

P[M-1] = P[M] + M/1

P[M-2] = P[M-1] + M/2

…

P[0] = P[1] + M/M

综上：P[0] = 0 + M/1 + M/2 + … + M/M，至此问题已经解决，不过我希望大家学到的不是这个答案，而是分析这个题目的过程

#### 最终答案：

0 + M/1 + M/2 + M/3 + … + M/M



###　问题二

[参考网址](<https://blog.csdn.net/pure_life/article/details/8106054>)

#### 问题描述：

这个笔试题来自今年的知名游戏公司，因为签了保密协定，为了避免麻烦，自行改编一下。

 

在一款游戏中，武器等级可以分为0-7级，武器每次升级需要一块宝石，每次升级可能出现三种情况：升一级、保持不变、降一级。

 

已知i->i+1升一级概率为Ai，保持不变概率为Bi，降一级概率为Ci。

A0～A7，B0～B7，C0～C7均已知，其中从等级0到等级1必定成功，即A0=1，B0=0，C0=0

 

现在问你将武器从0级升级到3级需要的宝石数的期望？

 

如果大家在看这篇博文之前，没有阅读我之前的博文：面试题中的概率问题-数学期望(1)，请大家先去看看，主要关注【数学期望中的递归特性】

 

#### 分析过程：
设f(x,y)表示从x升级到y的宝石数期望，则：

f(0,3)  =  1 + f(1,3)

f(1,3)  =  A1*(1+f(2,3)) + B1*(1+f(1,3)) + C1*(1+f(0,3))

f(2,3) =  A2*1 + B2*(1+f(2,3)) + C2*(1+f(1,3))

很明显，这是一个三元一次方程组，必定可以计算出f(0,3)，f(1,3)，f(2,3)

其中f(0,3)为最终的答案

 

其实，这个思想并不难，关键是有没有想到，下面做简单分析

f(0,3)用一块宝石升级到1级后，继续的期望是f(1,3) =>  f(0,3) = 1 +f(1,3)
f(x,y)用一块宝石升级一次后，有Ax的概率升一级，之后期望为f(x+1,y)，这部分为Ax*(1+f(x+1,y))，之后部分类似分析，即可得到 f(x,y) = Ax*(1+f(x+1,y)) + Bx*(1+f(x,y)) + Cx*(1+f(x-1,y))，关于x与y的大小，还有一些边界就自己去考虑吧
f(x,x)为0

#### 最终答案：

如果我们令[A0,B0,C0] = [1,0,0] ，[A1,B1,C1] = [1/3,1/3,1/3]，[A2,B2,C2] = [1/9,4/9,4/9] ，那么f(0,3) = 30  f(1,3) = 29   f(2,3) = 25

 

注意，根据我们上面简单分析中的第二条f(x,y)的计算，其实可以解决升级到任意等级的需要的宝石数，包括将最高等级扩展到N，只要有对应的[Ai,Bi,Ci]，因为实际上最后问题都是一个方程组，可以编程来解决，参考矩阵的相关知识，见数值计算。

##　概率论

<https://blog.csdn.net/BertDai/article/details/78070092>

待整理