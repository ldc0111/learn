kill杀死进程的原理

<http://zyearn.github.io/blog/2015/03/22/what-happens-when-you-kill-a-process/>

执行`kill -9 <PID>`，进程是怎么知道自己被发送了一个信号的？首先要产生信号，执行kill程序需要一个pid，根据这个pid找到这个进程的task_struct（这个是Linux下表示进程/线程的结构），然后在这个结构体的特定的成员变量里记下这个信号。 这时候信号产生了但还没有被特定的进程处理，叫做Pending signal。 等到下一次CPU调度到这个进程的时候，内核会保证先执行`do_signal`这个函数看看有没有需要被处理的信号，若有，则处理；若没有，那么就直接继续执行该进程。所以我们看到，在Linux下，信号并不像中断那样有异步行为，而是每次调度到这个进程都是检查一下有没有未处理的信号。

　　内核调度到该进程时，会调用`do_notify_resume`来处理信号队列中的信号，之后这个函数又会调用`do_signal`，再调用`handle_signal`，具体过程就不用代码说明了，最后会找到每一个信号的处理函数，问题是这个怎么找到？

还记得在上文提到的task_struct吗，里面有一个成员变量`sighand_struct`就是用来存储每个信号的处理函数的。



100g数据，1g内存

代码实现