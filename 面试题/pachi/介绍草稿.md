Pachi 围棋框架源码阅读
C/C++
Linux
源码解读
• 项目介绍:
2017 年 9 月
Pachi 是一个简单的模块化围棋游戏框架。
• 源码亮点:
• 亮点: 通过函数指针数组的技巧对相应的引擎进行初始化;对库函数进行二次封装以提高其健壮性;在
棋局相关的内部条件判断中使用 Linux 内核中的 likely 和 unlikely 宏,提高 CPU 进行分支预测的成功率。
• 亮点:Pachi 中的分布式版本主要是依靠 distributed(Maste) 和 UCT(Slave) 两个引擎共同完成,Master 在每
次向 Slave 发送消息前首先会收集整理共享 tree_node 数据,然后发送共享 tree_node 数据给各个 Slave,每
个 Slave 各自存储一棵树并且在没有命令的时候每个 Slave 均在持续的做 pondering。
• 亮点:对手局中 Pachi 会” 深思熟虑”,MCTS 在后台进行情况模拟,利用对手时间增加模拟次数。当对手
落子后,Pachi 能在 MCT 中搜索到最有状态并将最优节点进行提根操作,回收多余节点,降低空间开销。







Pachi 围棋项目
2017 年 7 月– 2017 年 7 月
源码解读 团队项目
• 该项目是 Alphago 的前身框架。
• 对库函数 malloc 进行处理,避免了过程中出现开辟地址失败的情况。
• 在不使用 if 的情况下,可直接获取对方棋子颜色。
• 在使用策略上有 8 种引擎可以选择,通过函数数组的指针的方式可直接对相应的引擎进行初始化。
• 在存储棋局状态坐标时,将二维坐标处理成一个整型进行存储。
• 在对方进行思考的过程中,蒙特卡罗树继续进行后台下棋模拟,这样可以大大的增加模拟次数。
当对方落棋后,根据蒙特卡罗树的特殊构造,我们可以迅速在树中找到当前棋局状态并且提升为
根节点,然后回收全部多余结点,节省空间。



Pachi 源码阅读
Linux,C++ 个人项目
• 了解了蒙特卡洛树搜索的过程及其中棋盘设置和落子策略的选择以及对蒙特卡罗树的剪枝的过程
• 重点阅读了关于多线程的内容,掌握了有关多线程的知识,如:线程安全,上锁解锁问题及死锁
产生的原因等
• 对 uct 算法及 ucb 算法有所了解



了解了蒙特卡洛树搜索的过程及其中棋盘设置和落子策略的选择以及对蒙特卡罗树的剪枝的过程

通过枚举类型和函数指针数组的技巧对相应的引擎进行初始化;对库函数进行二次封装以提高其健壮性;在
棋局相关的内部条件判断中使用 Linux 内核中的 likely 和 unlikely 宏,提高 CPU 进行分支预测的成功率。

Pachi 中的分布式版本主要是依靠 distributed(Maste) 和 UCT(Slave) 两个引擎共同完成,Master 在每
次向 Slave 发送消息前首先会收集整理共享 tree_node 数据,然后发送共享 tree_node 数据给各个 Slave,每
个 Slave 各自存储一棵树并且在没有命令的时候每个 Slave 均在持续的做 pondering。















### gtp_cmd

第一次：初始化gtp_cmd地址指向gtp_cmds,gtp_id初始化为-1,gtp_cmd的值为　id 命令和命令参数，然后将last初始化为NULL,存入命令，如果是新的命令last指向第一个history地址，讲id复制为这次的id，但是第一次他没有将命令存入这个地方，然后他将last->next_cmd置为0，在distribute_genmove中函数的最后会调用一个　update_cmd(b, "play", args, true); 命令，然后他才会将next_cmd指向gtp_cmd，所以我猜测在每个命令下面都有一个类似update_cmd(b, "play", args, true);的命令，只同步可以改变棋盘状态的命令