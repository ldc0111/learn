[牛客精华网址](<https://www.nowcoder.com/ta/review-c>)

## 1.基础语言

 ### 1、说一下**static**关键字的作用 

[c语言中](<https://blog.csdn.net/guotianqing/article/details/79828100>)

**静态局部变量**: 使用static修饰符定义，即使在声明时未赋初值，编译器也会把它初始化为0。且静态局部变量存储于进程的全局数据区，即使函数返回，它的值也会保持不变。

> 变量在全局数据区分配内存空间；编译器自动对其初始化  其作用域为局部作用域，当定义它的函数结束时，其作用域随之结束

**静态全局变量**:仅对当前文件可见，其他文件不可访问，其他文件可以定义与其同名的变量，两者互不影响。

> 在定义不需要与其他文件共享的全局变量时，加上static关键字能够有效地降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用。

**函数:**函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数。其特性如下：

- 静态函数只能在声明它的文件中可见，其他文件不能引用该函数
- 不同的文件可以使用相同名字的静态函数，互不影响

[c++面向对象](<https://blog.csdn.net/guotianqing/article/details/79828100>)

**静态数据成员**:
在类内数据成员的声明前加上static关键字，该数据成员就是类内的静态数据成员。其特点如下：

* 静态数据成员存储在全局数据区，静态数据成员在定义时分配存储空间，所以不能在类声明中定义
* 静态数据成员是类的成员，无论定义了多少个类的对象，静态数据成员的拷贝只有一个，且对该类的所有对象可见。也就是说任一对象都可以对静态数据成员进行操作。而对于非静态数据成员，每个对象都有自己的一份拷贝。
* 由于上面的原因，静态数据成员不属于任何对象，在没有类的实例时其作用域就可见，在没有任何对象时，就可以进行操作
* 和普通数据成员一样，静态数据成员也遵从`public, protected, private`访问规则
* 静态数据成员的初始化格式：`<数据类型><类名>::<静态数据成员名>=<值>`
* 类的静态数据成员有两种访问方式：`<类对象名>.<静态数据成员名> 或 <类类型名>::<静态数据成员名>`

**静态成员函数**
与静态数据成员类似，静态成员函数属于整个类，而不是某一个对象，其特性如下：

* 静态成员函数没有this指针，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数
* 出现在类体外的函数定义不能指定关键字static
* 非静态成员函数可以任意地访问静态成员函数和静态数据成员

### 2、说一下C++和C的区别 

[参考网址](<https://blog.csdn.net/zqixiao_09/article/details/51235444>) :想要详细的知道的话，建议观看

1. C++是C的超集，也可以说C是C++的子集，因为C先出现。按常理说，C++编译器能够编译任何C程序，但是C和C++还是有一些小差别。编程范式不一样c语言是面向过程，c++面向对象，同时c++支持４种编程范式
2. 关键字和变量:如　bool类型
3. 强制类型转换
4. 标准输入输出流
5. **函数参数问题**
6. 函数重载
7. **变量作用域**
8. **new和delete运算符**
9. 引用型变量

### 3、说一下C++中static关键字的作用 

　同第一题

### 4、请说一下static的作用 

同第一题

[参考网址](<https://www.nowcoder.com/ta/review-c/review?page=23>)

1. 全局静态变量

在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。

静态存储区，在整个程序运行期间一直存在。

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。

作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

2. 局部静态变量

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

内存中的位置：静态存储区。

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。

作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。

3. 静态函数

在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突。

warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰。

4. 类的静态成员

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。

5. 类的静态函数

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

### 5、说一说c++中四种cast转换 

[参考网址](<https://www.nowcoder.com/ta/review-c/review?tpId=22&tqId=21066&query=&asc=true&order=&page=17>)

C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast

1、const_cast

用于将const变量转为非const

2、static_cast

用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；

3、dynamic_cast

用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。

向上转换：指的是子类向基类的转换

向下转换：指的是基类向子类的转换

它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

4、reinterpret_cast

几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

5、为什么不使用C的强制转换？

C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。



### 6、请说一下C/C++ 中指针和引用的区别？ 

[参考网址](<https://blog.csdn.net/chaipp0607/article/details/77429380>)

**引用**是C++对C语言的一个补充，它的作用是为一个变量起一个别名。 

1）非空区别： 
在任何情况下都不能使用指向空值的引用， 一个引用必须总是指向某些对象。 换句话说一个引用在声明的时候就必须要初始化（除了作为函数的参数），而指针是没有这个问题的，我们在定义一个指针但是不让它指向任何对象，是完全可以的：

```c
//错误，需要初始值
int &b;
//正确
int *p;
```

因此如果你使用一个变量并让它指向一个对象，但是该变量在某些时候也可能不指向任何对象，这时你应该把变量声明为指针，因为这样你可以赋空值给该变量。 相反，如果变量肯定指向一个对象，例如你的设计不允许变量为空，这时你就可以把变量声明为引用。不存在指向空值的引用这个事实意味着使用引用的代码效率比使用指针要高。

（2）合法性区别： 
在使用引用之前不需要测试它的合法性。 相反，指针则应该总是被测试，防止其为空。这个问题和上面的其实是对应的，既然指针在定义的时候可以为空，但是一个为空的指针对实现一个功能是没有用的，为了代码的鲁棒性，我们必须时刻考虑指针为空的情况，这在指针作为函数的参数时尤为常见。

（3）可修改区别： 
指针与引用的另一个重要的区别是指针可以被重新赋值以指向另一个不同的对象。 但是引用则总是指向在初始化时被指定的对象，以后不能改变，但是指定的对象其内容可以改变。 

由于引用的声明和初始化总是在一起的，所以不可能让一个对象的引用指向另一个，这完全没有道理，假设a的引用是c，那么在执行int &c=b;就重定义了，如果执行c = b;，那么只是把b的值赋值给c，也就是a。

（4）应用区别： 
以上的特性决定了指针和引用的一些应用上的区别，总的来说，在以下情况下应该使用指针：一是考虑到存在不指向任何对象的可能（在这种情况下，能够设置指针为空），二是需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。 如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么应该使用引用。

（5）补充 

不能建立数组的引用，指针是可以代表数组的，指向数组的指针是数组的首地址，但是引用是不可以的。



### 7、给定三角形ABC和一点P(x,y,z)，判断点P是否在ABC内，给出思路并手写代码 

[四种方法](<https://blog.csdn.net/tianhai110/article/details/5411003>)

没兴趣看。。。

### 8、怎么判断一个数是二的倍数，怎么求一个数中有几个1，说一下你的思路并手写代码  

```C
num & 1 == 0;
```

```c
//四种做法
超级大暴力
每次减去最后一位１
加和法
打表法
```



### 9、请你说一下你理解的c++中的smart pointer四个智能指针： 

[参考网址](<https://blog.csdn.net/zyq522376829/article/details/48177535>)

 	unique_ptr: 如果内存资源的所有权不需要共享，就应当使用这个（它没有拷贝构造函数），但是它可以转让给另一个unique_ptr（存在move构造函数）。
        shared_ptr: 如果内存资源需要共享，那么使用这个（所以叫这个名字）。
        weak_ptr: 持有被shared_ptr所管理对象的引用，但是不会改变引用计数值。它被用来打破依赖循环（想象在一个tree结构中，父节点通过一个共享所有权的引用(chared_ptr)引用子节点，同时子节点又必须持有父节点的引用。如果这第二个引用也共享所有权，就会导致一个循环，最终两个节点内存都无法释放）。



### 11、请你回答一下野指针是什么？ 

指向一个已删除的对象或未申请访问受限内存区域的指针。



### 12、请你介绍一下C++中的智能指针  

同第九题

### 13、请你回答一下智能指针有没有内存泄露的情况 

[参考网址](<https://blog.csdn.net/daniel_ustc/article/details/23096229>)

有，环形引用

可以用weak_ptr来打破环形引用

### 14、请你来说一下智能指针的内存泄漏如何解决 

同13题

### 15、请你理解的c++中的引用和指针 

同第６题

### 16、请你来说一下C++中的智能指针  

同第九题

### 17、请你回答一下为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数 

[参考地址](<https://www.nowcoder.com/questionTerminal/c5877c00c2f44f09b149777ca90eaf23?orderByHotValue=1&page=1&onlyReference=false>) 

析构函数不一定必须是虚函数，是否为虚函数取决于该类的。

一般该类为基类产生继承和多态时，才会是虚函数，单独使用可以不是虚函数。

之所以在继承和多态时设计为虚函数是因为当new派生类并且用基类指针指向这个派生类，在销毁基类指针时只会调用基类的析构函数，不会调用派生类的析构函数，因为基类无法操作派生类中非继承的成员，这样就造成派生类只new无法delete造成内存泄露。 

默认不是虚析构函数是因为如果析构函数为虚函数就需要编译器在类中增加虚函数表来实现虚函数机制，这样所需内存空间就更大了，因此没有必要默认为虚析构函数。

### 18、请你来说一下函数指针 

[参考网址](<https://blog.csdn.net/a1232345/article/details/43524371>)

这个不好解释

函数指针可以当做变量来使用，可以当函数参数来使用

也可以当做结构体变量，进行封装，总之非常方便。

### 19、请你来说一下fork函数

[参考网址](<https://www.nowcoder.com/questionTerminal/4cc3870762d34215894a3cfdbae86620?toCommentId=2513746>)

解释１：用于创建一个进程，调用一次，返回两次。返回值为0时，为子进程；返回值大于0时，为父进程。采用写时复制技术，因此fork的速度极快

解释２：C++的fork函数用来“复制”一份主程序，即创建主进程的子进程。调用fork的同时，我的理解是，已经在内存中创建了“副本”进程，同时返回pid，所以在返回值之前，已经是主进程和子进程同时在运行了（如果fork成功的话），这样，在程序的运行过程中，一次fork返回了两次值，在父进程中，fork返回新创建子进程的进程ID，在子进程中，fork返回0，这时候就能够同时跑两个进程了。

### 20、请你来说一下C++中析构函数的作用和调用

[参考网址](<https://blog.csdn.net/u013152895/article/details/44563421>)

如果构造函数打开了一个文件，最后不需要使用时文件就要被关闭。析构函数允许类自动完成类似清理工作，不必调用其他成员函数。

析构函数也是特殊的类成员函数。简单来说，析构函数与构造函数的作用正好相反，它用来完成对象被删除前的一些清理工作，也就是专门的扫尾工作。

[参考网址](https://blog.csdn.net/l1902090/article/details/38264209 )

  众所周知，c++中的每个类都会有一个析构函数，当这个类的对象被销毁的时候，对象会自动调用析构函数。那么什么情况下对象的析构函数会被自动调用呢？其实这个问题也可以换种方式问，什么情况下对象会被自动销毁。
    我们跟据对象的声明方式分两种情况来讲：
    1、动态声明的对象
    这种声明方式下系统会自动销毁不再使用的对象，对应的对象的析构函数也会被调用。例如classname object；这样声明的对象，当程序运行到了对象作用域之外或者程序退出，对象都会被销毁，当然析构函数也会被调用。
    2、静态声明的对象（new等）

这种声明方式下系统不会主动帮你销毁对象，对应的析构函数也不会被主动调用，除非你的程序显式地调用delete等函数。这种情况下只要你不去delete，对象的析构函数永远不会调用，即便这个对象的内存空间已经泄露或者程序退出。

### 21、请你来说一下静态函数和虚函数的区别

虚函数用来实现动态多态，父类函数加virtual关键字，子类同名函数（完全和父类一样的函数，只是方法体不同，也叫重写）可加可不加。如当父类指针指向子类对象时，调用的是子类的函数。 

[静态成员](https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)函数只能在该类中访问[静态成员](https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)变量（普通变量不能访问），在本类中有效，其他类不能访问该函数，[静态成员](https://www.baidu.com/s?wd=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)函数为类所有不为对象所有，对象调用时不传this指针。 

普通成员函数能访问本类中所有类型控制的成员变量。 随着对象的销毁，会自动调用析构函数，如果类中定义了析构函数，就调用此析构函数，如果没有定义，调用系统自带的析构函数。

[参考网址](<https://www.cnblogs.com/lakeone/p/5967548.html>)

#### 1.virtual与静态函数

C++中，静态成员函数不能被声明为virtual函数。

 

```c
#include<iostream>
class Test
{
   public:
      // 编译错误：static成员函数不能声明为virtual   
      virtual static void fun()  { }
};
```

```c
#include<iostream>
class Test
{
   public:
      // 编译错误: static成员函数不能为const
      static void fun() const { }

      // 如果声明为下面这样，是可以的。
      const static void fun() {}
      或类似于
      const static int fun() { return 0; }
};
```

#### 2.为何static成员函数不能为virtual

1. static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。
2. 静态与非静态成员函数之间有一个主要的区别。那就是静态成员函数没有this指针。

   虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.

   对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual.

   **虚函数的调用关系：this -> vptr -> vtable ->virtual function**

通过下面例子可以确定，当类增加了一个虚函数后，类的大小会增大4字节(指针的大小).

```c
class Test
{
public:
      int _m;
};

sizeof(Test) = 4;

加入虚函数后，

class Test
{
public:
      int _m;
      virtual void fun();
};

//sizeof(Test) = 8

```

 

#### **3.为何static成员函数不能为const函数**

当声明一个非静态成员函数为const时，对this指针会有影响。对于一个Test类中的const修饰的成员函数，this指针相当于Test const *, 而对于非const成员函数，this指针相当于Test *.

  而static成员函数没有this指针，所以使用const来修饰static成员函数没有任何意义。

  volatile的道理也是如此。

```c


public:
      int _m;
      virtual void fun();
};

//sizeof(Test) = 8
 
```

#### 4.static 可以继承吗？

[参考网址](<https://blog.csdn.net/herostarone/article/details/7330981>)

1.   父类的static变量和函数在派生类中依然可用，但是受访问性控制（比如，父类的private域中的就不可访问），而且对static变量来说，派生类和父类中的static变量是共用空间的，这点在利用static变量进行引用计数的时候要特别注意。   

  2.   static函数没有“虚函数”一说。因为static函数实际上是“加上了访问控制的全局函数”，全局函数哪来的什么虚函数？   

  3.   派生类的friend函数可以访问派生类本身的一切变量，包括从父类继承下来的protected域中的变量。但是对父类来说，他并不是friend的。

继承可以使得子类具有父类的各种属性和方法，而不需要再次编写相同的代码。

### 22、请你来说一说重载，覆盖和重写的区别 

**Overload(重载)**：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载。

（1）相同的范围（在同一个类中）；
（2）函数名字相同；
（3）参数不同；
（4）virtual 关键字可有可无。

**Override(覆盖)**：是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有virtual 关键字。

**Overwrite(重写)**：是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual
关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual
关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。

### 23、请你来说一说static关键字  

同第一题

### 24、请你说一说strcpy和strlen

strcpy是字符串拷贝函数，原型：

char *strcpy(char* dest, const char *src);

从src逐字节拷贝到dest，直到遇到'\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞,安全版本是strncpy函数。
strlen函数是计算字符串长度的函数，返回从开始到'\0'之间的字符个数。

#### stacpy的实现

```c
char * strcpy( char *strDest, const char *strSrc ) 
{
	assert( (strDest != NULL) && (strSrc != NULL) );
 	char *address = strDest; 
 	while( (*strDest++ = * strSrc++) != ‘\0’ ); 
 	return address;
 }
```

strlen

```c
/* strlen: return length of s */
int strlen(char s[])
{
	int i;
	while (s[i] != '\0')
	++i;
	return i;
}
```

### 25、请你说一说你理解的虚函数和多态 

[参考网址](<https://blog.csdn.net/houbin01/article/details/7867773>)

解释１：**c++的多态性用一句话概括：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象的类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。**

[参考网址](<https://zhidao.baidu.com/question/331835442539341365.html>)

解释２：一个基类的多个子类有相似功能但又不一样，即仅仅函数体不同。 通过指向基类的指针或引用来调用子类的虚函数，从而实现多态。

### 26、请你来回答一下++i和i++的区别

1. ++i称先自增，把储存器中i的值增加1，再取出来参与本次运算。
2. i++称后自增，先把储存器中i的值取出来参与本次运算，储存器中i的值再增加1。

### 27、请你来说一说++i和i++的实现

[参考网址](<https://blog.csdn.net/qnavy123/article/details/79482999>)

++i

```c++
     int&  int::operator++（）
         {
             *this +=1；
             return *this；
         }
```

i++

```c
 const int  int::operator（int）
         {
             int oldValue = *this；
             ++（*this）；
              return oldValue；
         }
```



### 28、请你来写个函数在main函数执行前先运行 

```c
__attribute__((constructor))
void func () {
	return ;
}
```



### 29、有段代码写成了下边这样，如果在只修改一个字符的前提下，使代码输出20个hello?

```c
for(int i = 0; i < 20; i--)
cout << "hello" << endl;
```

```c
for(int i=0;-i < 20; i--)
    cout << "hello" << endl;
```





### 30、请你来说一下智能指针shared_ptr的实现  

> 　shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用在weak_ptr中有介绍。

shared_ptr是最常用的智能指针（项目中我只用过shared_ptr）。shared_ptr采用了引用计数器，多个shared_ptr中的T *ptr指向同一个内存区域（同一个对象），并共同维护同一个引用计数器。shared_ptr定义如下,记录同一个实例被引用的次数，当引用次数大于0时可用，等于0时释放内存。

```c++
temple<typename T>
2 class SharedPtr {
3 public:
4    ... 
5 private:
6     T *_ptr;
7     int *_refCount;     //should be int*, rather than int
8 };
```

shared_ptr对象每次离开作用域时会自动调用析构函数，而析构函数并不像其他类的析构函数一样，而是在释放

内存是先判断引用计数器是否为0。等于0才做delete操作，否则只对引用计数器左减一操作。

```c++
~SharedPtr()
{
    if (_ptr && --*_refCount == 0) {
        delete _ptr;
        delete _refCount;
    }
}
```

当用一个shared_ptr<T> other去给另一个 shared_ptr<T> sp赋值时，发生了两件事情：

1. sp指针指向发生变化，不再指向之前的内存区域，所以赋值前原来的_refCount要自减

2. sp指针指向other.ptr，所以other的引用计数器_refCount要做++操作。

```c++
SharedPtr &operator=(SharedPtr &other)
{
    if(this==&other)
        return *this;
        
    ++*other._refCount;
    if (--*_refCount == 0) {
        delete _ptr;
        delete _refCount;
    }
        
    _ptr = other._ptr;
    _refCount = other._refCount;
    return *this;
}
```
### 31、以下四行代码的区别是什么？  

[参考网址](https://www.nowcoder.com/questionTerminal/df82ea33b3094a0c9267ad9b91e77845)

```c
const char * arr = "123";
char * brr = "123";
const char crr[] = "123";
char drr[] = "123";
```

https://www.nowcoder.com/questionTerminal/df82ea33b3094a0c9267ad9b91e77845

1. 声明指向串“123”的一个常量字符指针 

  2. 编译错误，“123”是const char* 类型的指针，不能用来初始化char* 指针 

3. 初始化一个常量字符数组，相当于const char crr1[4] = { '1','2','3' };  （要特别注意字符数组的长度） 

  既然是常量数组，那么再对它执行下列操作就是错误的了 

​     crr[4] = "12";   （表达式必须是可以被修改的左值）

4. 声明一个指向“123”的字符数组： 

  举例说明一些问题： 

​      char * ptr;  drr = ptr;      // 错误，drr是不可以被修改的值 

### 32、请你来说一下C++里是怎么定义常量的？常量存放在内存的哪个位置？

c++中定义常量有两种方法：

1. 使用`#define`预处理器：`#define MAX_N 1000`
2. 使用`const`关键字：`const int max = 1000;`
3. 因为无法解释const栈变量的存储位置。实际上并不存在常量存储区，只有全局/静态存储区。**const**类型的存储跟一般的变量没有区别，在外部定义的存储在全局数据区，static的存储在静态数据区，在函数内部定义的存储在栈，const跟非const存储上没区别，只不过是read only的。

### 33、请你来回答一下const修饰成员函数的目的是什么？  

[参考网址](<https://www.nowcoder.com/ta/review-c/review?query=&asc=true&order=knowledgePoint&page=72>)

const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。

### 34、如果同时定义了两个函数，一个带const，一个不带，会有问题吗？

不会，这相当于函数的重载。

在同一个类里，同时存在一个const方法和一个普通方法是没问题的。

### 

### 35、请你来说一说隐式类型转换

* 为什么要进行隐式类型转换？

  C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。

  通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。

  在比如，数值和布尔类型的转换，整数和浮点数的转换等。

  某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。

  C++是一门强类型语言，类型的检查是非常严格的。

  如果没有类型的隐式转换，这将给程序开发者带来很多的不便。

  当然，凡事都有两面性，在你享受方便快捷的一面时，你不得不面对太过智能以至完全超出了你的控制。

  风险就在不知不觉间出现。、

* c++隐式类型转换的原则：

  - 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。
    隐式转换发生在从小->大的转换中。比如从char转换为int。
    从int-》long。
  - 自定义对象 子类对象可以隐式的转换为父类对象。

* c++隐式转换发生的条件：

  > 低精度向高精度转换

  * 混合类型的算术运算表达式中：

    ```c++
    int a = 3;
    double = 4.5;
    a = b;
    ```

  * 不同类型的复制操作：

    ```c++
    int a = true;
    int * ptr = nullptr;
    ```

  * 函数参数传值：

    ```c++
    void func(double a);
    func(1);
    ```

  * 函数返回值：

    ```c++
    double add (int a, int b) {
        return a + b;
    }
    ```



### 36、说说你了解的类型转换

[参考网址](<https://www.nowcoder.com/ta/review-c/review?tpId=22&tqId=31492&query=&asc=true&order=&page=170>)

reinterpret_cast：可以用于任意类型的指针之间的转换，对转换的结果不做任何保证
dynamic_cast：这种其实也是不被推荐使用的，更多使用static_cast，dynamic本身只能用于存在虚函数的父子关系的强制类型转换，对于指针，转换失败则返回nullptr，对于引用，转换失败会抛出异常
const_cast：对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。
static_cast：完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。

### 37、请你来说一说C++函数栈空间的最大值

默认是1M，不过可以调整

### 38、请你来说一说extern“C”

[参考网址](<https://www.cnblogs.com/carsonzhu/p/5272271.html>)

**extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。**

​     这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。

**这个功能主要用在下面的情况：**

1. C++代码调用C语言代码
2. 在C++的头文件中使用
3. 在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到

为什么标准头文件都有类似的结构？

```c
#ifndef __INCvxWorksh /*防止该头文件被重复引用*/
#define __INCvxWorksh
#ifdef __cplusplus             //告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的
extern "C"{
#endif
 
/*…*/
 
#ifdef __cplusplus
}
 
#endif
#endif /*end of __INCvxWorksh*/
```

分析：

- 显然，头文件中编译宏"#ifndef __INCvxWorksh 、#define __INCvxWorksh、#endif"的作用是为了防止该头文件被重复引用

 



### 39、请你回答一下new/delete与malloc/free的区别是什么

[参考网址](<https://blog.csdn.net/qq_33573235/article/details/79485266>)

1、new、delete是C++中的操作符，而malloc和free是标准库函数。

2、对于非内部数据对象来说，只使用malloc是无法完成动态对象要求的，一般在创建对象时需要调用构造函数，对象消亡时，自动的调用析构函数。而malloc free是库函数而不是运算符，不在编译器控制范围之内，不能够自动调用构造函数和析构函数。而NEW在为对象申请分配内存空间时，可以自动调用构造函数，同时也可以完成对对象的初始化。同理，delete也可以自动调用析构函数。而mallloc只是做一件事，只是为变量分配了内存，同理，free也只是释放变量的内存。

3、new返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而 malloc需要我们计算申请内存的大小，并且在返回时强行转换为实际类型的指针。

### new 和 delete 到底是什么？

如果找工作的同学看一些面试的书，我相信都会遇到这样的题：sizeof 不是函数，然后举出一堆的理由来证明 sizeof 不是函数。在这里，和 sizeof 类似，new 和 delete 也不是函数，它们都是 C++ 定义的关键字，通过特定的语法可以组成表达式。和 sizeof 不同的是，sizeof 在编译时候就可以确定其返回值，new 和 delete 背后的机制则比较复杂。

继续往下之前，请你想想你认为 new 应该要做些什么？也许你第一反应是，new 不就和 C 语言中的 malloc 函数一样嘛，就用来动态申请空间的。你答对了一半，看看下面语句：

```c
string *ps = new string("hello world");
```

你就可以看出 new 和 malloc 还是有点不同的，malloc 申请完空间之后不会对内存进行必要的初始化，而 new 可以。所以 new expression 背后要做的事情不是你想象的那么简单。在我用实例来解释 new 背后的机制之前，你需要知道 operator new 和 operator delete 是什么玩意。

### operator new 和 operator delete

这两个其实是 C++ 语言标准库的库函数，原型分别如下： 

```c
void *operator new(size_t);     //allocate an object
void *operator delete(void *);    //free an object

void *operator new[](size_t);     //allocate an array
void *operator delete[](void *);    //free an array
```

后面两个你可以先不看，后面再介绍。前面两个均是 C++ 标准库函数，你可能会觉得这是函数吗？请不要怀疑，这就是函数！C++ Primer 一书上说这不是重载 new 和 delete 表达式（如 operator= 就是重载 = 操作符），因为 new 和 delete 是不允许重载的。但我还没搞清楚为什么要用 operator new 和 operator delete 来命名，比较费解。我们只要知道它们的意思就可以了，这两个函数和 C 语言中的 malloc 和 free 函数有点像了，都是用来申请和释放内存的，并且 operator new 申请内存之后不对内存进行初始化，直接返回申请内存的指针。

我们可以直接在我们的程序中使用这几个函数。

### new 和 delete 背后机制

知道上面两个函数之后，我们用一个实例来解释 new 和 delete 背后的机制：

我们不用简单的 C++ 内置类型来举例，使用复杂一点的类类型，定义一个类 A：

```c
class A
{
public:
    A(int v) : var(v)
    {
        fopen_s(&file, "test", "r");
    }
    ~A()
    {
        fclose(file);
    }

private:
    int var;
    FILE *file;
};
```

很简单，类 A 中有两个私有成员，有一个构造函数和一个析构函数，构造函数中初始化私有变量 var 以及打开一个文件，析构函数关闭打开的文件。

我们使用

```c
class *pA = new A(10);
```

来创建一个类的对象，返回其指针 pA。如下图所示 new 背后完成的工作：

 来创建一个类的对象，返回其指针 pA。如下图所示 new 背后完成的工作：

![](/home/tesla/github/learn/面试题/语言基础jpg/operator_new.jpeg)

简单总结一下：

首先需要调用上面提到的 operator new 标准库函数，传入的参数为 class A 的大小，这里为 8 个字节，至于为什么是 8 个字节，你可以看看《深入 C++ 对象模型》一书，这里不做多解释。这样函数返回的是分配内存的起始地址，这里假设是 0x007da290。
上面分配的内存是未初始化的，也是未类型化的，第二步就在这一块原始的内存上对类对象进行初始化，调用的是相应的构造函数，这里是调用 A:A(10); 这个函数，从图中也可以看到对这块申请的内存进行了初始化，var=10, file 指向打开的文件。
最后一步就是返回新分配并构造好的对象的指针，这里 pA 就指向 0x007da290 这块内存，pA 的类型为类 A 对象的指针。

所有这三步，你都可以通过反汇编找到相应的汇编代码，在这里我就不列出了.

好了，那么 delete 都干了什么呢？还是接着上面的例子，如果这时想释放掉申请的类的对象怎么办？当然我们可以使用下面的语句来完成：

```c
delete pA;
```

delete 所做的事情如下图所示：

![](/home/tesla/github/learn/面试题/语言基础jpg/operator_delete.jpeg)

delete 就做了两件事情：

调用 pA 指向对象的析构函数，对打开的文件进行关闭。
通过上面提到的标准库函数 operator delete 来释放该对象的内存，传入函数的参数为 pA 的值，也就是 0x007d290。

好了，解释完了 new 和 delete 背后所做的事情了，是不是觉得也很简单？不就多了一个构造函数和析构函数的调用嘛。

如何申请和释放一个数组？
我们经常要用到动态分配一个数组，也许是这样的：

```c
string *psa = new string[10];      //array of 10 empty strings
int *pia = new int[10];           //array of 10 uninitialized ints
```

上面在申请一个数组时都用到了 new [] 这个表达式来完成，按照我们上面讲到的 new 和 delete 知识，第一个数组是 string 类型，分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素；第二个是申请具有内置类型的数组，分配了存储 10 个 int 对象的内存空间，但并没有初始化。

如果我们想释放空间了，可以用下面两条语句：

````
delete [] psa;
delete [] pia;
````

都用到 delete [] 表达式，注意这地方的 [] 一般情况下不能漏掉！我们也可以想象这两个语句分别干了什么：第一个对 10 个 string 对象分别调用析构函数，然后再释放掉为对象分配的所有内存空间；第二个因为是内置类型不存在析构函数，直接释放为 10 个 int 型分配的所有内存空间。

这里对于第一种情况就有一个问题了：我们如何知道 psa 指向对象的数组的大小？怎么知道调用几次析构函数？

这个问题直接导致我们需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。

还是用图来说明比较清楚，我们定义了一个类 A，但不具体描述类的内容，这个类中有显示的构造函数、析构函数等。那么 当我们调用

```c
class A *pAa = new A[3];
```

时需要做的事情如下：

![](/home/tesla/github/learn/面试题/语言基础jpg/oper_new.jpeg)

从这个图中我们可以看到申请时在数组对象的上面还多分配了 4 个字节用来保存数组的大小，但是最终返回的是对象数组的指针，而不是所有分配空间的起始地址。

这样的话，释放就很简单了：

```c
delete [] pAa;
```

![](/home/tesla/github/learn/面试题/语言基础jpg/oper_delete.jpeg)

这里要注意的两点是：

- 调用析构函数的次数是从数组对象指针前面的 4 个字节中取出；
- 传入 `operator delete[]` 函数的参数不是数组对象的指针 pAa，而是 pAa 的值减 4。

 为什么 new/delete 、new []/delete[] 要配对使用？
其实说了这么多，还没到我写这篇文章的最原始意图。从上面解释的你应该懂了 new/delete、new[]/delete[] 的工作原理了，因为它们之间有差别，所以需要配对使用。但偏偏问题不是这么简单，这也是我遇到的问题，如下这段代码：

```c
int *pia = new int[10];
delete []pia;
```




这肯定是没问题的，但如果把 delete []pia; 换成 delete pia; 的话，会出问题吗？

这就涉及到上面一节没提到的问题了。上面我提到了在 new [] 时多分配 4 个字节的缘由，因为析构时需要知道数组的大小，但如果不调用析构函数呢（如内置类型，这里的 int 数组）？我们在 new [] 时就没必要多分配那 4 个字节， delete [] 时直接到第二步释放为 int 数组分配的空间。如果这里使用 delete pia;那么将会调用 operator delete 函数，传入的参数是分配给数组的起始地址，所做的事情就是释放掉这块内存空间。不存在问题的。

这里说的使用 new [] 用 delete 来释放对象的提前是：对象的类型是内置类型或者是无自定义的析构函数的类类型！

我们看看如果是带有自定义析构函数的类类型，用 new [] 来创建类对象数组，而用 delete 来释放会发生什么？用上面的例子来说明：

```c
class A *pAa = new class A[3];
delete pAa;
```

那么 delete pAa; 做了两件事：

调用一次 pAa 指向的对象的析构函数；
调用 operator delete(pAa); 释放内存。
显然，这里只对数组的第一个类对象调用了析构函数，后面的两个对象均没调用析构函数，如果类对象中申请了大量的内存需要在析构函数中释放，而你却在销毁数组对象时少调用了析构函数，这会造成内存泄漏。

上面的问题你如果说没关系的话，那么第二点就是致命的了！直接释放 pAa 指向的内存空间，这个总是会造成严重的段错误，程序必然会奔溃！因为分配的空间的起始地址是 pAa 指向的地方减去 4 个字节的地方。你应该传入参数设为那个地址！

同理，你可以分析如果使用 new 来分配，用 delete [] 来释放会出现什么问题？是不是总会导致程序错误？

总的来说，记住一点即可：new/delete、new[]/delete[] 要配套使用总是没错的！





### 40、请你说说你了解的RTTI

[参考网址](<https://www.nowcoder.com/ta/review-c/review?tpId=22&tqId=31496&query=&asc=true&order=&page=174>)



运行时类型检查，在C++层面主要体现在dynamic_cast和typeid,VS中虚函数表的-1位置存放了指向type_info的指针。对于存在虚函数的类型，typeid和dynamic_cast都会去查询type_info



[详细网址](<https://www.jb51.net/article/55968.htm>)

RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它**提供了运行时确定对象类型的方法**。RTTI并不是什么新的东西，很早就有了这个技术，但是，在实际应用中使用的比较少而已。而我这里就是对RTTI进行总结，今天我没有用到，并不代表这个东西没用。学无止境，先从typeid函数开始讲起。

**typeid函数**

typeid的主要作用就是让用户知道当前的变量是什么类型的

```c
#include <typeinfo> 
float f = 1.0f;
double d = 2;
cout<<typeid(f).name()<<endl; // float
cout<<typeid(d).name()<<endl; // double
//结构体依然支持 
```

是的，对于我们自定义的结构体和类，tpyeid都能支持。在上面的代码中，在调用完typeid之后，都会接着调用name()函数，可以看出typeid函数返回的是一个结构体或者类，然后，再调用这个返回的结构体或类的name成员函数；其实，typeid是一个返回类型为type_info类型的函数。那么，我们就有必要对这个type_info类进行总结一下，毕竟它实际上存放着类型信息。

**type_info类**

去掉那些该死的宏，在Visual Studio 2012中查看type_info类的定义如下：

```c
class type_info
{
public:
    virtual ~type_info();
    bool operator==(const type_info& _Rhs) const; // 用于比较两个对象的类型是否相等
    bool operator!=(const type_info& _Rhs) const; // 用于比较两个对象的类型是否不相等
    bool before(const type_info& _Rhs) const;
 
    // 返回对象的类型名字，这个函数用的很多
    const char* name(__type_info_node* __ptype_info_node = &__type_info_root_node) const;
    const char* raw_name() const;
private:
    void *_M_data;
    char _M_d_name[1];
    type_info(const type_info& _Rhs);
    type_info& operator=(const type_info& _Rhs);
    static const char * _Name_base(const type_info *,__type_info_node* __ptype_info_node);
    static void _Type_info_dtor(type_info *);
};
```

在type_info类中，复制构造函数和赋值运算符都是私有的，同时也没有默认的构造函数；所以，我们没有办法创建type_info类的变量，例如type_info A;这样是错误的。那么typeid函数是如何返回一个type_info类的对象的引用的呢？我在这里不进行讨论，思路就是类的友元函数。

 **typeid函数的使用**

typeid使用起来是非常简单的，常用的方式有以下两种：

1.使用type_info类中的name()函数返回对象的类型名称

就像上面的代码中使用的那样；但是，这里有一点需要注意，比如有以下代码： 

省略，，，，



### 41、请你说说虚函数表具体是怎样实现运行时多态的?

[参考网址](<https://blog.csdn.net/u014796694/article/details/80641871>)

（1）每一个含有虚函数的类，都会生成虚表(virtual table)。这个表，记录了对象的动态类型，决定了执行此对象的虚成员函数的时候，真正执行的那一个成员函数。

（2）对于有多个基类的类对象，会有多个虚表，每一个基类对应一个虚表，同时，虚表的顺序和继承时的顺序相同。

（3）在每一个类对象所占用的内存中，虚指针位于最前边，每个虚指针指向对应的虚表。



### 42、请你说说C语言是怎么进行函数调用的？

[参考网址](<https://www.nowcoder.com/ta/review-c/review?query=&asc=true&order=knowledgePoint&page=75>)

每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。

### 43、请你说说C语言参数压栈顺序？

[参考网址](<https://blog.csdn.net/liangkaiming/article/details/6230779>)

[详细参考网址](<https://my.oschina.net/N3verL4nd/blog/866969>)

程序栈底为高地址，栈顶为低地址，因此上面的实例可以说明函数参数入栈顺序的确是从右至左的。可到底为什么呢？查了一直些文献得知，参数入栈顺序是和具体编译器实现相关的。比如，Pascal语言中参数就是从左到右入栈的，有些语言中还可以通过修饰符进行指定，如Visual C++。即然两种方式都可以，为什么Ｃ语言要选择从右至左呢？

进一步发现，Pascal语言不支持可变长参数，而Ｃ语言支持这种特色，正是这个原因使得Ｃ语言函数参数入栈顺序为从右至左。具体原因为：C方式参数入栈顺序（从右至左）的好处就是可以**动态变化参数个数**。通过栈堆分析可知，自左向右的入栈方式，最前面的参数被压在栈底。除非知道参数个数，否则是无法通过栈指针的相对位移求得最左边的参数。这样就变成了左边参数的个数不确定，正好和动态参数个数的方向相反。

因此，Ｃ语言函数参数采用自右向左的入栈顺序，主要原因是为了支持可变长参数形式，C语言中可变参数都是从左到右，所以不管你有多少个参数反正将最右面的那个压入栈底，最左面的参数出入栈顶。换句话说，如果不支持这个特色，Ｃ语言完全和Pascal一样，采用自左向右的参数入栈方式。

### 44、请你说说C++如何处理返回值？

[参考网址](<https://www.nowcoder.com/ta/review-c/review?page=178>)

生成一个临时变量，把它的引用作为函数参数传入函数内。

### 45、请你回答一下C++中拷贝赋值函数的形参能否进行值传递？

不可以，

[参考网址](<https://blog.csdn.net/liu0808/article/details/80373424>)

无限递归。

```c
#include <iostream.h>

class CExample
{
	int m_nTest;
public:
	
	CExample(int x):m_nTest(x) //带参数构造函数
	{ 
	   cout << "constructor with argument/n";
	}
	
	CExample(const CExample & ex) //拷贝构造函数
	{
		m_nTest = ex.m_nTest;
		cout << "copy constructor/n";
	}
	
	CExample& operator = (const CExample &ex)//赋值函数(赋值运算符重载)
	{	
		cout << "assignment operator/n";
		m_nTest = ex.m_nTest;
		return *this;
	}
	
	void myTestFunc(CExample ex)
	{
	}
};

int main()
{
	CExample aaa(2);
	CExample bbb(3);
	bbb = aaa;
	CExample ccc = aaa;
	bbb.myTestFunc(aaa);
	
	return 0;	
}

看这个例子的输出结果：

constructor with argument     //CExample aaa(2);
constructor with argument     //CExample bbb(3);
assignment operator           //bbb = aaa;
copy constructor              //CExample ccc = aaa;
copy constructor              //  bbb.myTestFunc(aaa);


```



构造ccc，实质上是ccc.CExample(aaa); 我们假如拷贝构造函数参数不是引用类型的话， 那么将使得 ccc.CExample(aaa)变成aaa传值给ccc.CExample(CExample ex)，即CExample ex = aaa，因为 ex 没有被初始化， 所以 CExample ex = aaa 继续调用拷贝构造函数，接下来的是构造ex，也就是 ex.CExample(aaa)，必然又会有aaa传给CExample(CExample ex), 即 CExample ex = aaa;那么又会触发拷贝构造函数，就这下永远的递归下去。



### 46、请你回答一下malloc与new区别

[参考网址](<https://www.nowcoder.com/ta/review-c/review?page=173>)

首先，new/delete是C++的关键字，而malloc/free是C语言的库函数，后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数

### 47、请你说一说select

selcet函数是一个轮循函数，即当循环询问文件节点，可设置超时时间，超时时间到了就跳过代码继续往下执行。select()的机制中提供一fd_set的数据结构，实际上是一long类型的数组， 每一个数组元素都能与一打开的文件句柄(不管是Socket句柄，还是其他 文件或命名管道或设备句柄)建立联系，建立联系的工作由程序员完成， 当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执 行了select()的进程哪一Socket或文件可读或可写。主要用于Socket通信当中。



### 48、请你说说fork,wait,exec函数  

[参考网址](<https://www.nowcoder.com/ta/review-c/review?tpId=22&tqId=31504&query=&asc=true&order=&page=182>)

父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存，exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0.调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1

### 49、请你回答一下静态函数和虚函数的区别

[参考网址](<https://www.nowcoder.com/ta/review-c/review?tpId=22&tqId=31505&query=&asc=true&order=&page=183>)

静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销



逻辑角度说静态员函数绑定class旦定义应class改变；虚函数意义恰恰运行态选择调用哪class同名函数本质矛盾同使用实现角度说静态成员函数本质与C函数致应内存固定址；虚函数应虚表索引值运行通索引值进行间接寻址两者兼容所论逻辑合理性实现行性说虚函数都必须非静态员函数



### 50、请你说一说重载和覆盖

同２２题

### 51、请你说一说static关键字

同第一题

### 52、请你说一说strcpy和strlen

同２４题



 

## **2、容器和算法**  

  **1、请你来说一下**map和set有什么区别，**分别又是**怎么实现的 

[参考网址](<https://blog.csdn.net/Dawn_sf/article/details/78506299>)

MAP的节点是一对数据.    SET的节点是一个数据.

分别实现见参考网址或者第14题



  **2、**请你来**介绍一下**STL的allocaotr

[参考网址１](<https://www.nowcoder.com/questionTerminal/fee6cd20a2324d908bfafdc9dd1df0af?orderByHotValue=1&page=1&onlyReference=false>)

 空间配置器，由两级分配器构成，大于128字节，调用一级配置器，malloc/free，realloc；小于128字节，默认二级配置器，分配内存池。为了便于内存管理，减少内存碎片产生

为一些泛型容器分配内存 使用户不必担心内存问题 只要添加数据即可

简单来说，是为了各种泛型容器如vector，map等分配内存，使程序员不比为内存而担心，只需添加数据即可

[参考网址２详细](<https://www.cnblogs.com/zhuwbox/p/3699977.html>)

一般而言，我们习惯的 C++ 内存配置操作和释放操作是这样的：

```
1 class FOO{};
2 FOO *pf = new FOO;    
3 delete pf;
```

　　我们看其中第二行和第三行，虽然都是只有一句，当是都完成了两个动作。但你 new 一个对象的时候两个动作是：先调用::operator new 分配一个对象大小的内存，然后在这个内存上调用FOO::FOO()构造对象。同样，当你 delete 一个对象的时候两个动作是：先调用FOO::~FOO() 析构掉对象，再调用::operator delete将对象所处的内存释放。为了精密分工，STL 将allocator决定将这两个阶段分开。分别用 4 个函数来实现：

　　1.内存的配置：alloc::allocate();

　　2.对象的构造：::construct();

　　3.对象的析构：::destroy();

　　4.内存的释放：alloc::deallocate();

　　其中的 construct() 和 destroy()定义在 STL的库文件中，源代码如下：

```c
template <class T>
inline void destroy(T* pointer) {
    pointer->~T();                               //只是做了一层包装，将指针所指的对象析构---通过直接调用类的析构函数
}

template <class T1, class T2>
inline void construct(T1* p, const T2& value) {
  new (p) T1(value);                            //用placement new在 p 所指的对象上创建一个对象，value是初始化对象的值。
}

template <class ForwardIterator>                //destory的泛化版，接受两个迭代器为参数
inline void destroy(ForwardIterator first, ForwardIterator last) {
  __destroy(first, last, value_type(first));    //调用内置的 __destory(),value_type()萃取迭代器所指元素的型别
}

template <class ForwardIterator, class T>
inline void __destroy(ForwardIterator first, ForwardIterator last, T*) {
  typedef typename __type_traits<T>::has_trivial_destructor trivial_destructor;
  __destroy_aux(first, last, trivial_destructor());        //trival_destructor()相当于用来判断迭代器所指型别是否有 trival destructor
}


template <class ForwardIterator>
inline void                                                //如果无 trival destructor ，那就要调用destroy()函数对两个迭代器之间的对象元素进行一个个析构
__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) {
  for ( ; first < last; ++first)
    destroy(&*first);
}

template <class ForwardIterator>                        //如果有 trival destructor ，则什么也不用做。这更省时间
inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}

inline void destroy(char*, char*) {}          //针对 char * 的特化版
inline void destroy(wchar_t*, wchar_t*) {}    //针对 wchar_t*的特化版
```

看到上面这么多代码，大家肯定觉得 construct() 和 destroy() 函数很复杂。其实不然，我们看到construct()函数只有几行代码。而 destroy() 稍微多点。但是这么做都是为了提高销毁对象时的效率。为什么要判断迭代器所指型别是否有 trival destructor，然后分别调用不同的执行函数？因为当你要销毁的对象很多的时候，而这样对象的型别的destructor 都是 trival 的。如果都是用__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)来进行销毁的话很费时间，因为没必要那样做。而当你对象的destructor 都是 non-trival 的时候，你又必须要用__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)来析构。所以，我们要判断出对象型别的destructor 是否为 trival，然后调用不同的__destroy_aux。

　　说完 construct() 和 destory() ，我们来说说 alloc::allocate() 和 alloc::deallocate()，其源代码在 <stl_alloc.h>中。stl_alloc.h中代码设计的原则如下：

　　1.向 system heap 要求空间

　　2.考虑多线程状态

　　3.考虑内存不足时的应变措施

　　4.考虑过多“小型区块”可能造成的内存碎片问题。

　　stl_alloc.h中的代码相当复杂，不过没关系。我们今天只看其中的allocate() 和 deallocate()。在讲这两个函数之前，我们还必须来了解一下SGI  STL(SGI限定词是STL的一个版本，因为真正的STL有很多不同公司实现的版本，我们所讨论的都是SGI版本) 配置器的工作原理：

　　考虑到小型区块可能造成内存破碎问题(即形成内存碎片)，SGI STL 设计了双层级配置器。第一层配置器直接使用malloc() 和 free().第二层配置器则视情况采用不同的策略：但配置区块超过 128 bytes时，调用第一级配置器。当配置区块小于 128 bytes时，采用复杂的 memory pool 方式。下面我们分别简单的介绍一下第一级和第二级配置器：

**第一级配置器 _ _malloc_alloc_template：**

　　由于第一级配置器的配置方法比较简单，代码也容易理解，我在这里全部贴出：

```c
//以下是第第一级配置器
template <int inst>
class __malloc_alloc_template {

private:

//以下函数用来处理内存不足的情况
static void *oom_malloc(size_t);

static void *oom_realloc(void *, size_t);

static void (* __malloc_alloc_oom_handler)();

public:

static void * allocate(size_t n)
{
    void *result = malloc(n);                    //第一级配置器，直接使用malloc()
    //如果内存不足，则调用内存不足处理函数oom_alloc()来申请内存
    if (0 == result) result = oom_malloc(n);
    return result;
}

static void deallocate(void *p, size_t /* n */)
{
    free(p);            //第一级配置器直接使用 free()
}

static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz)
{
    void * result = realloc(p, new_sz);            //第一级配置器直接使用realloc()
    //当内存不足时，则调用内存不足处理函数oom_realloc()来申请内存
    if (0 == result) result = oom_realloc(p, new_sz);
    return result;
}

//设置自定义的out-of-memory handle就像set_new_handle()函数
static void (* set_malloc_handler(void (*f)()))()
{
    void (* old)() = __malloc_alloc_oom_handler;
    __malloc_alloc_oom_handler = f;
    return(old);
}
};

template <int inst>　　　　
void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;　　//内存处理函数指针为空，等待客户端赋值

template <int inst>
void * __malloc_alloc_template<inst>::oom_malloc(size_t n)
{
    void (* my_malloc_handler)();
    void *result;

    for (;;) {                                                     //死循环
        my_malloc_handler = __malloc_alloc_oom_handler;            //设定自己的oom(out of memory)处理函数
        if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }         //如果没有设定自己的oom处理函数，毫不客气的抛出异常
        (*my_malloc_handler)();                                    //设定了就调用oom处理函数
        result = malloc(n);                                        //再次尝试申请
        if (result) return(result);
    }
}

template <int inst>
void * __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n)
{
    void (* my_malloc_handler)();
    void *result;

    for (;;) {
        my_malloc_handler = __malloc_alloc_oom_handler;
        if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; }    //如果自己没有定义oom处理函数，则编译器毫不客气的抛出异常
        (*my_malloc_handler)();                                //执行自定义的oom处理函数
        result = realloc(p, n);                                //重新分配空间
        if (result) return(result);                            //如果分配到了，返回指向内存的指针
    }
}
```

上面代码看似繁杂，其实流程是这样的：

　　1.我们通过allocate()申请内存，通过deallocate()来释放内存，通过reallocate()重新分配内存。

　　2.当allocate()或reallocate()分配内存不足时会调用oom_malloc()或oom_remalloc()来处理。

　　3.当oom_malloc() 或 oom_remalloc()还是没能分配到申请的内存时，会转如下两步中的一步：

　　　　a).调用用户自定义的内存分配不足处理函数(这个函数通过set_malloc_handler() 来设定)，然后继续申请内存！

　　　　b).如果用户未定义内存分配不足处理函数，程序就会抛出bad_alloc异常或利用exit(1)终止程序。

　　看完这个流程，再看看上面的代码就会容易理解多了！

**第二级配置器 _ _default_alloc_template：**

　　第二级配置器的代码很多，这里我们只贴出其中的 allocate() 和 dellocate()函数的实现和工作流程(参考侯捷先生的《STL源码剖析》)，而在看函数实现代码之前，我大致的描述一下第二层配置器配置内存的机制。

　　我们之前说过，当申请的内存大于 128 bytes时就调用第一层配置器。当申请的内存小于 128bytes时才会调用第二层配置器。第二层配置器如何维护128bytes一下内存的配置呢？ SGI 第二层配置器定义了一个 free-lists,这个free-list是一个数组，如下图：

　　![img](https://images0.cnblogs.com/i/566545/201404/291845299705479.png)

　　这数组的元素都是指针，用来指向16个链表的表头。这16个链表上面挂的都是可以用的内存块。只是不同链表中元素的内存块大小不一样，16个链表上分别挂着大小为

　　 8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128 bytes的小额区块，图如下：

　　 ![img](https://images0.cnblogs.com/i/566545/201404/291901512525167.png)

　　就是这样，现在我们来看allocate()代码：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 static void * allocate(size_t n)
  {
    obj * __VOLATILE * my_free_list;
    obj * __RESTRICT result;
    
    //要申请的空间大于128bytes就调用第一级配置
    if (n > (size_t) __MAX_BYTES) {
        return(malloc_alloc::allocate(n));
    }
    //寻找 16 个free lists中恰当的一个
    my_free_list = free_list + FREELIST_INDEX(n);
    result = *my_free_list;
    if (result == 0) {
        //没找到可用的free list，准备新填充free list
        void *r = refill(ROUND_UP(n));
        return r;
    }
    *my_free_list = result -> free_list_link;
    return (result);
  };
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　其中有两个函数我来提一下，一个是ROUND_UP()，这个是将要申请的内存字节数上调为8的倍数。因为我们free-lists中挂的内存块大小都是8的倍数嘛，这样才知道应该去找哪一个链表。另一个就是refill()。这个是在没找到可用的free list的时候调用，准备填充free lists.意思是：参考上图，假设我现在要申请大小为 56bytes 的内存空间，那么就会到free lists 的第 7 个元素所指的链表上去找。如果此时 #7元素所指的链表为空怎么办？这个时候就要调用refill()函数向内存池申请N(一般为20个)个大小为56bytes的内存区块，然后挂到 #7 所指的链表上。这样，申请者就可以得到内存块了。当然，这里为了避免复杂，误导读者我就不讨论refill()函数了。allocate()过程图如下：

　　![img](https://images0.cnblogs.com/i/566545/201404/291925362832756.png)

　　学过链表的操作的人不难理解上图，我就不再讲解。下面看deallocate()，代码如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
 1 static void deallocate(void *p, size_t n)
 2 {
 3     obj *q = (obj *)p;
 4     obj * __VOLATILE * my_free_list;
 5 
 6     //如果要释放的字节数大于128，则调第一级配置器
 7     if (n > (size_t) __MAX_BYTES) {
 8         malloc_alloc::deallocate(p, n);
 9         return;
10     }
11     //寻找对应的位置
12     my_free_list = free_list + FREELIST_INDEX(n);
13     //以下两步将待释放的块加到链表上
14     q -> free_list_link = *my_free_list;    
15     *my_free_list = q;
16 }
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　deallocate()函数释放内存的步骤如下图：

![img](https://images0.cnblogs.com/i/566545/201404/291941302052751.png)

　　其实这就是一个链表的插入操作，也很简单。不再赘述！上面忘了给链表结点的结构体定义了，如下：

```
union obj{
    union obj * free_list_link;
    char client_date[1]; 
};
```

　　至此，SGI STL的对象的构造与析构、内存的分配与释放就介绍完毕了。

 



  **3、请你来说一说**STL迭代器删除元素 

[参考网址](<https://blog.csdn.net/yf_li123/article/details/75003425#comments>)

对于关联容器（如map，set，multimap，multiset），删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前的iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入，删除一个结点不会对其他结点造成影响。使用方式如下例子：

```c
set<int> valset = { 1,2,3,4,5,6 };
set<int>::iterator iter;
for (iter = valset.begin(); iter != valset.end(); )
{
     if (3 == *iter)
          valset.erase(iter++);
     else
          ++iter;
}
```

 因为传给erase的是iter的一个副本，iter++是下一个有效的迭代器。

（2）对于序列式容器（如vector，deque，list等），删除当前的iterator会使后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。不过erase方法可以返回下一个有效的iterator。使用方式如下,例如：

```c
vector<int> val = { 1,2,3,4,5,6 };
vector<int>::iterator iter;
for (iter = val.begin(); iter != val.end(); )
{
     if (3 == *iter)
          iter = val.erase(iter);     //返回下一个有效的迭代器，无需+1
     else
          ++iter;
}
```





  **4、请你说一说STL中MAP数据存放形式**  

[参考网址](<https://blog.csdn.net/Dawn_sf/article/details/78506299>)

分别实现见参考网址或者第14题



  **5、请你讲讲STL有什么基本组成**  

[参考网址](<https://blog.csdn.net/bingxuebage/article/details/5729064>)

STL有三大核心部分：容器（Container）、算法（Algorithms）、迭代器（Iterator），容器适配器（container adaptor），函数对象(functor)，除此之外还有STL其他标准组件。通俗的讲：

容器：装东西的东西，装水的杯子，装咸水的大海，装人的教室……STL里的容器是可容纳一些数据的模板类。

算法：就是往杯子里倒水，往大海里排污，从教室里撵人……STL里的算法，就是处理容器里面数据的方法、操作。

迭代器：往杯子里倒水的水壶，排污的管道，撵人的那个物业管理人员……STL里的迭代器：遍历容器中数据的对象。对存储于容器中的数据进行处理时，迭代器能从一个成员移向另一个成员。他能按预先定义的顺序在某些容器中的成员间移动。对普通的一维数组、向量、双端队列和列表来说，迭代器是一种指针。

下面让我们来看看专家是怎么说的：

容器（container）：容器是数据在内存中组织的方法，例如，数组、堆栈、队列、链表或二叉树（不过这些都不是STL标准容器）。STL中的容器是一种存储T（Template）类型值的有限集合的数据结构,容器的内部实现一般是类。这些值可以是对象本身，如果数据类型T代表的是Class的话。

算法（algorithm）：算法是应用在容器上以各种方法处理其内容的行为或功能。例如，有对容器内容排序、复制、检索和合并的算法。在STL中，算法是由模板函数表现的。这些函数不是容器类的成员函数。相反，它们是独立的函数。令人吃惊的特点之一就是其算法如此通用。不仅可以将其用于STL容器，而且可以用于普通的C＋＋数组或任何其他应用程序指定的容器。

迭代器(iterator)：一旦选定一种容器类型和数据行为(算法)，那么剩下唯一要他做的就是用迭代器使其相互作用。可以把达代器看作一个指向容器中元素的普通指针。可以如递增一个指针那样递增迭代器，使其依次指向容器中每一个后继的元素。迭代器是STL的一个关键部分，因为它将算法和容器连在一起。

1.       容器

STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。

2.  算法（algorithm）：

`#inlcude <algorithm>`

STL中算法的大部分都不作为某些特定容器类的成员函数，他们是泛型的，每个算法都有处理大量不同容器类中数据的使用。值得注意的是，STL中的算法大多有多种版本，用户可以依照具体的情况选择合适版本。中在STL的泛型算法中有4类基本的算法：

变序型队列算法：可以改变容器内的数据；

3.       迭代器（itertor）：

`#include<iterator>`

迭代器实际上是一种泛化指针，如果一个迭代器指向了容器中的某一成员，那么迭代器将可以通过自增自减来遍历容器中的所有成员。迭代器是联系容器和算法的媒介，是算法操作容器的接口。在运用算法操作容器的时候，我们常常在不知不觉中已经使用了迭代器。
STL中定义了6种迭代器：

输入迭代器，在容器的连续区间内向前移动，可以读取容器内任意值；

输出迭代器，把值写进它所指向的队列成员中；

前向迭代器，读取队列中的值，并可以向前移动到下一位置（++p,p++）；

双向迭代器，读取队列中的值，并可以向前向后遍历容器；

随机访问迭代器, vector<T>::iterator，list<T>::iterator等都是这种迭代器 ；

流迭代器，可以直接输出、输入流中的值；

4.       STL的其他标准组件

函数对象（functor或者funtion objects）

`#include<functional>`

函数对象又称之为仿函数。函数对象将函数封装在一个对象中，使得它可作为参数传递给合适的STL算法，从而使算法的功能得以扩展。可以把它当作函数来使用。用户也可以定义自己的函数对象。下面让我们来定义一个自己的函数对象.



  **6、请你说说STL中map与unordered_map**  

1. map存储结构是红黑树，所以需要定义比较函数（less），查找效率为O(logN).
2. unordered_map存储结构是数组，需要定义hash函数（计算key）和比较函数(equal)，查找效率为O(1).
3. unordered_map就是hash_map.
4. insert、find、[]等方法形式上一致。 
[参考网址](<https://www.cnblogs.com/mfryf/p/10024311.html>)

map： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。 

unordered_map: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。







  **7**、**请你说一说**vector和list的区别，应用，越详细越好

[参考网址](<https://blog.csdn.net/liuzhenghui666666/article/details/77600399>)

向量（Vector）：循秩访问（Rank）,类似与RAM中每给定一个位置i，都可以在O(1)的时间里找到它对其进行操作。

列表(List)：循位置访问(position),类似与图灵机，纸带无限长，我们可以操控其中一个单元，某一时刻，我们访问距离他较远的位置时，我们只能通过一步一步的迭代来实现。

有序情况下 
在需要查找一个元素时，我们的Vector的效率为O（logn）,List的效率为O（n）； 
在需要添加删除一个元素时，我们的Vector的效率是O(n),List的效率为O（1）； 

因此当我们的查找操作较多时，可以用Vector来实现效率更高，当添加删除操作较多时，我们用List来实现时效率更高。



  **8**、**请你来说一下**STL中迭代器的作用，有指针为何还要迭代器 

[参考网址](<https://www.zhihu.com/question/54047747>)

迭代器实际上是对“遍历容器”这一操作进行了封装。
在编程中我们往往会用到各种各样的容器，但由于这些容器的底层实现各不相同，所以对他们进行遍历的方法也是不同的。例如，数组使用指针算数就可以遍历，但链表就要在不同节点直接进行跳转。
这是非常不利于代码重用的。例如你有一个简单的查找容器中最小值的函数findMin，如果没有迭代器，那么你就必须定义适用于数组版本的findMin和适用于链表版本的findMin，如果以后有更多容器需要使用findMin，那就只好继续添加重载……而如果每个容器又需要更多的函数例如findMax，sort，那简直就是重载地狱……
我们的救星就是迭代器啦！如果我们将这些遍历容器的操作都封装成迭代器，那么诸如findMin一类的算法就都可以针对迭代器编程而不是针对具体容器编程，工作量一下子就少了很多！
至于指针，由于指针也可以用来遍历容器(数组)，所以指针也可是算是迭代器的一种。但是指针还有其他功能，并不只局限于遍历数组。因为使用指针变量数组的操作太深入人心，c++stl中的迭代器就是刻意仿照指针来设计接口的



  **9、请你说一说epoll原理**  

[参考网址-select与epoll介绍](<https://blog.csdn.net/wangfeng2500/article/details/9127421>)

这里就不在复制了

[比较解释](<https://www.nowcoder.com/questionTerminal/894d71ef93ce487e9c7243c4bc53eee7?>)

select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。 

  存在的问题： 

  1. 内置数组的形式使得select的最大文件数受限与FD_SIZE； 

  2. 每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态； 

  3. 轮寻排查当文件描述符个数很多时，效率很低； 

  3、poll 

  poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。 

  4、epoll 

  epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。 

  epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式 

1. LT模式 

  LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。 

  2. ET模式 

  ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once) 

  ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 

  3、LT模式与ET模式的区别如下：
 LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
 ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。

  **10、请你说一说STL迭代器是怎么删除元素的呢**  

见第三题



  **11、请你说一说STL中MAP数据存放形式**  

[参考网址](<https://blog.csdn.net/Dawn_sf/article/details/78506299>)

分别实现见参考网址或者第14题



  **12、n个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为O(N)**  

单调栈

  **13、请你回答一下STL里resize和reserve的区别**  

[参考网址](<https://blog.csdn.net/WLFIGHTER/article/details/50134411>)

resize 调整的是vector的大小，改变的是vector的size；如果resize的调整值小于vector的size，则会删除多余的元素；如果大于size，则增加元素。

reserve 调整的是vector的预分配的内存，改变的是vector的capacity。如果reserve的调整值大于vector的capacity，则会增加预分配的内存；如果小于capacity，则不做任何改变。



  **14**、**请你说一说**stl里面set和map怎么实现的 

[参考文档—详细代码](https://blog.csdn.net/Dawn_sf/article/details/78506299)

Set和Map其实就是一层马甲，对他们来说只是封装了底层的红黑树，只不过他们传入红黑树KeyOfValue的参数不同.而后面

的KeyOfValue才是决定，RBTreeNode当中的_valueField与key比较时，返回的是Key还是pair<>.first. 我下面还有一幅图用来帮大家理解这整个复用

代码的框架. 大家仔细看一定会明白这里的KeyOfValue模板参数，以及_ValueType的作用. 如果理解这些那么Map和Set的简易实现应该就差不多了.

![](/home/tesla/github/learn/面试题/语言基础jpg/map_and_set.png)



##  **3、类和数据抽象**  

  **1.**请你来说一下**C**++**中类成员的访问权限**  

C++类的重要属性就是封装和继承。因此，最关键的问题就是权限 的问题，public，protected，private 控制的就是访问权限。

**访问控制**

|                            | public | protected | private |
| -------------------------- | ------ | --------- | ------- |
| 类成员是否可以访问         | Yes    | Yes       | Yes     |
| 友元函数是否可以访问       | Yes    | Yes       | Yes     |
| 子类是否可以访问           | Yes    | Yes       | No      |
| 类的实例化对象是否可以访问 | Yes    | No        | No      |


**继承**

|               | public    | protected | private |
| ------------- | --------- | --------- | ------- |
| public继承    | public    | protected | private |
| protected继承 | protected | protected | private |
| private继承   | private   | private   | private |

  **2、请你来说一下C++中struct和class的区别**  

[参考网址](<https://blog.csdn.net/yuliu0552/article/details/6717915>)

1. struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的
2. **默认的继承访问权限**struct是public的，class是private的。

**struct可以继承class**，同样**class也可以继承struct**，那么默认的继承访问权限是看子类到底是用的struct还是class。

struct可以在定义的时候用{}赋初值。

当我们向struct中加入一个构造函数（或虚函数），你会发现什么？ 对，struct也不能用{}赋初值了 

的确，以{}的方式来赋初值，只是用一个初始化列表来对数据进行按顺序的初始化，如上面如果写成A a={'p',7};则c1,n2被初始化，而db3没有。这样简单的copy操作，只能发生在简单的数据结构上，而不应该放在对象上。加入一个构造函数或是一个虚函数会使struct更体现出一种对象的特性，而使此{}操作不再有效。 

这里可能有些混淆。为什么有些时候不写缺省构造函数就是有一个缺省构造函数，有些时候就不是呢？因为编译器只会在这个类没有任何构造函数被写出来的情况下会替我们生成一个缺省构造函数，除非我们使用了`=default`。具体到我们的例子里，因为`point`已经有`point(int v)`和`point(int theX, int theY)`两个构造函数了，因此如果我们不写缺省构造函数，那么编译器就会认为这个类没有缺省构造函数。

  **3、请你回答一下C++类内可以定义引用数据成员吗？**  

可以，必须通过成员函数初始化列表初始化。

## **4、面向对象与泛型编程**

  **1、**请你回答一下什么是右值引用，跟左值**又**有什么区别？ 

### 左值、右值

在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。

### 右值、将亡值

在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。

C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值，或者转换为T&&的类型转换函数的返回值。

将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

### 左值引用、右值引用

[参考网址](<https://blog.csdn.net/hyman_yx/article/details/52044632>)

左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。

右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。

左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。

`````c
int &a = 2;       # 左值引用绑定到右值，编译失败
int b = 2;        # 非常量左值
const int &c = b; # 常量左值引用绑定到非常量左值，编译通过
const int d = 2;  # 常量左值
const int &e = c; # 常量左值引用绑定到常量左值，编译通过
const int &b =2;  # 常量左值引用绑定到右值，编程通过
`````

右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：

```c
int a;
int &&r1 = c;             # 编译失败
int &&r2 = std::move(a);  # 编译通过
```

下表列出了在C++11中各种引用类型可以引用的值的类型。值得注意的是，只要能够绑定右值的引用类型，都能够延长右值的生命期。 





## **5、编译与底层**  

  1、 **请你来说一下**一个C++源文件从文本到可执行文件经历的过程**？**  

[参考网址](<https://blog.csdn.net/sheng_ai/article/details/47860403>)

  1).预处理，产生.ii文件

2).编译，产生汇编文件(.s文件)

3).汇编，产生目标文件(.o或.obj文件)

4).链接,产生可执行文件(.out或.exe文件)

1.预处理
   预处理主要包含下面的内容：
a.对所有的“#define”进行宏展开；
b.处理所有的条件编译指令，比如“#if”,“#ifdef”，“#elif”，“#else”,“#endif”
c.处理“#include”指令，这个过程是递归的，也就是说被包含的文件可能还包含其他文件
d.删除所有的注释“//”和“/**/”
e.添加行号和文件标识
f.保留所有的“#pragma”编译器指令
    经过预处理后的.ii文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到.ii文件中。

2.编译
    编译的过程就是将预处理完的文件进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件(.s文件)



3.汇编
    汇编器是将汇编代码转变成机器可以执行的代码，每一个汇编语句几乎都对应一条机器指令。最终产生目标文件(.o或.obj文件)。



4.链接

链接的过程主要包括了地址和空间分配(Address and Storage Allocation)、符号决议(Symbol Resolution)和重定位(Relocation)

2、 **请你来回答一下**include**头文件的顺序以及双引号**””**和尖括号**的区别？ 

[参考网址](https://www.nowcoder.com/questionTerminal/c256cdf91b214943a6ae97994154235c?orderByHotValue=1&mutiTagIds=569&page=1&onlyReference=false)

系统头文件在前面，然后是第三方库头文件，最后是自己的头文件。 

  但是如果是头文件的cpp文件，先要包含自己的头文件，然后再按照上面的顺序。 

  “”先在当前目录查找有无该头文件，有则包含该目录下的头文件，没有则到系统指定的目录下找该头文件，而<>直接到系统指定的目录下查找该文件。

  3、 **请你回答一下**malloc的原理**，**另外**brk系统调用**和m**map**系统调用的作用分别是什么？ 

[参考网址](<https://blog.csdn.net/Apollon_krj/article/details/54565768>)

对于C++中new与delete的底层则是用malloc和free实现。而我们所用的malloc()、free()与内核之间的接口（桥梁）就是sbrk()等系统函数；当然我们也可以直接调用系统调用（系统函数）,达到同样的作用。我们可以用下面这幅图来描述基本内存相关操作之间的关系：

虽然使用系统调用会带来一定的好处，但是物极必反，系统调用并非能频繁使用。由于程序由用户进入内核层时，会将用户层的状态先封存起来，然后到内核层运行代码，运行结束以后，从内核层出来到用户层时，再把数据加载回来。因此，频繁的系统调用效率很低。今天我们就系统调用层面来对内存操作做进一步的了解。



描述： 
brk()和sbrk()改变程序间断点的位置。程序间断点就是程序数据段的结尾。（程序间断点是为初始化数据段的起始位置）.通过增加程序间断点进程可以更有效的申请内存 。当addr参数合理、系统有足够的内存并且不超过最大值时brk()函数将数据段结尾设置为addr,即间断点设置为addr。sbrk()将程序数据空间增加increment字节。当increment为0时则返回程序间断点的当前位置。

返回值： 
brk()成功返回0，失败返回-1并且设置errno值为ENOMEM（注：在mmap中会提到）。 

sbrk()成功返回之前的程序间断点地址。如果间断点值增加，那么这个指针（指的是返回的之前的间断点地址）是指向分配的新的内存的首地址。如果出错失败，就返回一个指针并设置errno全局变量的值为ENOMEM。

总结： 
这两个函数都用来改变 “program break” (程序间断点)的位置，改变数据段长度（Change data segment size），实现虚拟内存到物理内存的映射。 
brk()函数直接修改有效访问范围的末尾地址实现分配与回收。sbrk()参数函数中：当increment为正值时，间断点位置向后移动increment字节。同时返回移动之前的位置，相当于分配内存。当increment为负值时，位置向前移动increment字节，相当与于释放内存，其返回值没有实际意义。当increment为0时，不移动位置只返回当前位置。参数increment的符号决定了是分配还是回收内存。而关于program break的位置如图所示：

![](/home/tesla/github/learn/面试题/语言基础jpg/brk.jpeg)

2、mmap()与munmap():
mmap函数（地址映射）：mmap将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零(Linux堆空间未使用内存均清零)。这里我们只研究mmap的内存映射，而暂时不讨论文件方面的问题。关于mmap的文件映射的更详细的内容可参考认真分析mmap：[是什么 为什么 怎么用](<a href="http://www.cnblogs.com/huxiao-tee/p/4660352.html" rel="nofollow" target="_blank">认真分析mmap：是什么 为什么 怎么用</a>)

![](/home/tesla/github/learn/面试题/语言基础jpg/nmap.png)



[参考网址２](<https://blog.csdn.net/gfgdsg/article/details/42709943>)

Linux 的虚拟内存管理有几个关键概念： 

1、每个进程都有独立的虚拟地址空间，进程访问的虚拟地址并不是真正的物理地址； 
2、虚拟地址可通过每个进程上的页表(在每个进程的内核虚拟地址空间)与物理地址进行映射，获得真正物理地址； 
3、如果虚拟地址对应物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；如果此时物理内存已耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中。 

基于以上认识，进行了如下分析：
一、Linux 虚拟地址空间如何分布？
Linux 使用虚拟地址空间，大大增加了进程的寻址空间，由低地址到高地址分别为： 
1、只读段：该部分空间只能读，不可写；(包括：代码段、rodata 段(C常量字符串和#define定义的常量) )
2、数据段：保存全局变量、静态变量的空间； 
3、堆 ：就是平时所说的动态内存， malloc/new 大部分都来源于此。其中堆顶的位置可通过函数 brk 和 sbrk 进行动态调整。 
4、文件映射区域 ：如动态库、共享内存等映射物理空间的内存，一般是 mmap 函数所分配的虚拟地址空间。 
5、栈：用于维护函数调用的上下文空间，一般为 8M ，可通过 ulimit –s 查看。 

6、内核虚拟空间：用户代码不可见的内存区域，由内核管理(页表就存放在内核虚拟空间)。



**下面以一个例子来说明内存分配的原理：**

情况一、malloc小于128k的内存，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：

![](/home/tesla/github/learn/面试题/语言基础jpg/malloc_128.jpeg)

1、进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。
      其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。
      _edata指针（glibc里面定义）指向数据段的最高地址。 
2、进程调用A=malloc(30K)以后，内存空间如图2：
      malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。
      你可能会问：只要把_edata+30K就完成内存分配了？
      事实是这样的，_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。 

3、进程调用B=malloc(40K)以后，内存空间如图3。

**情况二、malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：**

![](/home/tesla/github/learn/面试题/语言基础jpg/malloc_d128.jpeg)

4、进程调用C=malloc(200K)以后，内存空间如图4：
      默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。
      这样子做主要是因为::
      brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。
      当然，还有其它的好处，也有坏处，再具体下去，有兴趣的同学可以去看glibc里面malloc的代码了。 
5、进程调用D=malloc(100K)以后，内存空间如图5；

6、进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放。

![](/home/tesla/github/learn/面试题/语言基础jpg/free.jpeg)

7、进程调用free(B)以后，如图7所示：
        B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？
当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。 
8、进程调用free(D)以后，如图8所示：
        B和D连接起来，变成一块140K的空闲内存。
9、默认情况下：
       当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示。

三、既然堆内内存brk和sbrk不能直接释放，为什么不全部使用 mmap 来分配，munmap直接释放呢？ 

        既然堆内碎片不能直接释放，导致疑似“内存泄露”问题，为什么 malloc 不全部使用 mmap 来实现呢(mmap分配的内存可以会通过 munmap 进行 free ，实现真正释放)？而是仅仅对于大于 128k 的大块内存才使用 mmap ？ 

        其实，进程向 OS 申请和释放地址空间的接口 sbrk/mmap/munmap 都是系统调用，频繁调用系统调用都比较消耗系统资源的。并且， mmap 申请的内存被 munmap 后，重新申请会产生更多的缺页中断。例如使用 mmap 分配 1M 空间，第一次调用产生了大量缺页中断 (1M/4K 次 ) ，当munmap 后再次分配 1M 空间，会再次产生大量缺页中断。缺页中断是内核行为，会导致内核态CPU消耗较大。另外，如果使用 mmap 分配小内存，会导致地址空间的分片更多，内核的管理负担更大。

同时堆是一个连续空间，并且堆内碎片由于没有归还 OS ，如果可重用碎片，再次访问该内存很可能不需产生任何系统调用和缺页中断，这将大大降低 CPU 的消耗。 因此， glibc 的 malloc 实现中，充分考虑了 sbrk 和 mmap 行为上的差异及优缺点，默认分配大块内存 (128k) 才使用 mmap 获得地址空间，也可通过 mallopt(M_MMAP_THRESHOLD, <SIZE>) 来修改这个临界值。

五、C语言的内存分配方式与malloc

C语言跟内存分配方式
（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运
算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
（3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多
     

      C语言跟内存申请相关的函数主要有 alloc,calloc,malloc,free,realloc,sbrk等.其中alloc是向栈申请内存,因此无需释放. malloc分配的内存是位于堆中的,并且没有初始化内存的内容,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.calloc则将初始化这部分的内存,设置为0. 而realloc则对malloc申请的内存进行大小的调整.申请的内存最终需要通过函数free来释放. 而sbrk则是增加数据段的大小;
       malloc/calloc/free基本上都是C函数库实现的,跟OS无关.C函数库内部通过一定的结构来保存当前有多少可用内存.如果程序 malloc的大小超出了库里所留存的空间,那么将首先调用brk系统调用来增加可用空间,然后再分配空间.free时,释放的内存并不立即返回给os, 而是保留在内部结构中. 可以打个比方: brk类似于批发,一次性的向OS申请大的内存,而malloc等函数则类似于零售,满足程序运行时的要求.这套机制类似于缓冲.
使用这套机制的原因: 系统调用不能支持任意大小的内存分配(有的系统调用只支持固定大小以及其倍数的内存申请,这样的话,对于小内存的分配会造成浪费; 系统调用申请内存代价昂贵,涉及到用户态和核心态的转换.
函数malloc()和calloc()都可以用来分配动态内存空间，但两者稍有区别。

      在Linux系统上，程序被载入内存时，内核为用户进程地址空间建立了代码段、数据段和堆栈段，在数据段与堆栈段之间的空闲区域用于动态内存分配。
      内核数据结构mm_struct中的成员变量start_code和end_code是进程代码段的起始和终止地址，start_data和 end_data是进程数据段的起始和终止地址，start_stack是进程堆栈段起始地址，start_brk是进程动态内存分配起始地址（堆的起始 地址），还有一个 brk（堆的当前最后地址），就是动态内存分配当前的终止地址。
C语言的动态内存分配基本函数是malloc()，在Linux上的基本实现是通过内核的brk系统调用。brk()是一个非常简单的系统调用，只是简单地改变mm_struct结构的成员变量brk的值。
      mmap系统调用实现了更有用的动态内存分配功能，可以将一个磁盘文件的全部或部分内容映射到用户空间中，进程读写文件的操作变成了读写内存的操作。在 linux/mm/mmap.c文件的do_mmap_pgoff()函数，是mmap系统调用实现的核心。do_mmap_pgoff()的代码，只是新建了一个vm_area_struct结构，并把file结构的参数赋值给其成员变量m_file，并没有把文件内容实际装入内存。

Linux内存管理的基本思想之一，是只有在真正访问一个地址的时候才建立这个地址的物理映射。





 4、 **请你说一说**C++的内存管理**是怎样的**？ 

[参考网址](<https://www.nowcoder.com/ta/review-c/review?page=47>)

在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。

代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。

数据段：存储程序中已初始化的全局变量和静态变量

bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。

堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。

映射区:存储动态链接库以及调用mmap函数进行的文件映射

栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值



  **5、请你来说一下**C++/C的内存分配 

[参考网址](<https://www.nowcoder.com/ta/review-c/review?tpId=22&tqId=31370&query=&asc=true&order=&page=48>)

![](/home/tesla/github/learn/面试题/语言基础jpg/c内存分配.png)

32bitCPU可寻址4G线性空间，每个进程都有各自独立的4G逻辑地址，其中0~3G是用户态空间，3~4G是内核空间，不同进程相同的逻辑地址会映射到不同的物理地址中。其逻辑地址其划分如下：

各个段说明如下：

3G用户空间和1G内核空间

静态区域：

text segment(代码段):包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。

data segment(数据段)：存储程序中已初始化的全局变量和静态变量

bss segment：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量，对于未初始化的全局变量和静态变量，程序运行main之前时会统一清零。即未初始化的全局变量编译器会初始化为0

动态区域：

heap（堆）： 当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。

memory mapping segment(映射区):存储动态链接库等文件映射、申请大内存（malloc时调用mmap函数）

stack（栈）：使用栈空间存储函数的返回地址、参数、局部变量、返回值，从高地址向低地址增长。在创建进程时会有一个最大栈大小，Linux可以通过ulimit命令指定。

  6、**请你回答一下**如何判断内存泄漏？ 

[参考网址](<https://www.nowcoder.com/ta/review-c/review?page=49>)

内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。



  **7**.**请你来说一下**什么时候会发生段错误 

[参考网址](<https://www.nowcoder.com/ta/review-c/review?page=50>)

段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：

使用野指针

试图修改字符串常量的内容

  **8**、**请你来回答一下什么是**memory leak**，**也就是**内存泄漏**  

[参考网址](<https://www.nowcoder.com/ta/review-c/review?page=51>)

内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。

内存泄漏的分类：

1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.
2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。
3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

  **9**、**请你来回答一下**new和malloc的区别 

[参考网址](<https://www.nowcoder.com/ta/review-c/review?page=52>)

1、new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；

2、new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。

3、new不仅分配一段内存，而且会调用构造函数，malloc不会。

4、new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。

5、new是一个操作符可以重载，malloc是一个库函数。

6、malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。

7、new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。

8、申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。



  **1**0**、**请你来说一下*共享内存相关api*   

[参考网址](<https://www.nowcoder.com/ta/review-c/review?tpId=22&tqId=31375&query=&asc=true&order=&page=53>)

Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys/shm.h中。

1）新建共享内存shmget

int shmget(key_t key,size_t size,int shmflg);

key：共享内存键值，可以理解为共享内存的唯一性标记。

size：共享内存大小

shmflag：创建进程和其他进程的读写权限标识。

返回值：相应的共享内存标识符，失败返回-1

2）连接共享内存到当前进程的地址空间shmat

void *shmat(int shm_id,const void *shm_addr,int shmflg);

shm_id：共享内存标识符

shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。

shmflg：标志位

返回值：指向共享内存第一个字节的指针，失败返回-1

3）当前进程分离共享内存shmdt

int shmdt(const void *shmaddr);

4）控制共享内存shmctl

和信号量的semctl函数类似，控制共享内存

int shmctl(int shm_id,int command,struct shmid_ds *buf);

shm_id：共享内存标识符

command: 有三个值

IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。

IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。

IPC_RMID:删除共享内存

buf：共享内存管理结构体。



  **11、请你来说一下**reactor模型组成 

reactor模型要求主线程只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程，除此之外，主线程不做任何其他实质性的工作，读写数据、接受新的连接以及处理客户请求均在工作线程中完成。其模型组成如下：

![](/home/tesla/github/learn/面试题/语言基础jpg/reactor.png)

1）Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接。

2）Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。

3）Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。

4）Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。

5）Concrete Event Handler：事件EventHandler接口，实现特定事件处理逻辑。

  **12、请\****自己设计**一下**如何采用单线程的方式处理高并发 

在单线程模型中，可以采用I/O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来



  **13、请你说说**C++如何处理内存泄漏？ 

使用varglind，mtrace检测

  **14**、**请你说说**select，epoll的区别**，**原理，性能，限制都说**一**说 

[参考网址](https://www.nowcoder.com/questionTerminal/894d71ef93ce487e9c7243c4bc53eee7?)

1）IO多路复用 

  IO复用模型在阻塞IO模型上多了一个select函数，select函数有一个参数是文件描述符集合，意思就是对这些的文件描述符进行循环监听，当某个文件描述符就绪的时候，就对这个文件描述符进行处理。 

  这种IO模型是属于阻塞的IO。但是由于它可以对多个文件描述符进行阻塞监听，所以它的效率比阻塞IO模型高效。 

![](/home/tesla/github/learn/面试题/语言基础jpg/oi复用.png)

IO多路复用就是我们说的select，poll，epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 

  当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 

  所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。 

  I/O多路复用和阻塞I/O其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。 

  所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。） 

  在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。 

  2、select 

  select：是最初解决IO阻塞问题的方法。用结构体fd_set来告诉内核监听多个文件描述符，该结构体被称为描述符集。由数组来维持哪些描述符被置位了。对结构体的操作封装在三个宏定义中。通过轮寻来查找是否有描述符要被处理。 

  存在的问题： 

  1. 内置数组的形式使得select的最大文件数受限与FD_SIZE； 

  2. 每次调用select前都要重新初始化描述符集，将fd从用户态拷贝到内核态，每次调用select后，都需要将fd从内核态拷贝到用户态； 

  3. 轮寻排查当文件描述符个数很多时，效率很低； 

  3、poll 

  poll：通过一个可变长度的数组解决了select文件描述符受限的问题。数组中元素是结构体，该结构体保存描述符的信息，每增加一个文件描述符就向数组中加入一个结构体，结构体只需要拷贝一次到内核态。poll解决了select重复初始化的问题。轮寻排查的问题未解决。 

  4、epoll 

  epoll：轮寻排查所有文件描述符的效率不高，使服务器并发能力受限。因此，epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。 

  epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式 

  \1. LT模式 

  LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。 

  \2. ET模式 

  ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once) 

  ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 

  3、LT模式与ET模式的区别如下：
 LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
 ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。

  **15、请你说一说**C++ STL **的**内存优化 

[参考网址](<https://www.nowcoder.com/questionTerminal/d24be434e438419790e30e83f2ca24c1?>)



1）二级配置器结构 

  STL内存管理使用二级内存配置器。 

  1、第一级配置器 

  第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。 

  一级空间配置器分配的是大于128字节的空间 

  如果分配不成功，调用句柄释放一部分内存 

  如果还不能分配成功，抛出异常 

  2、第二级配置器 

  在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。 

  3、分配原则 

  如果要分配的区块大于128bytes，则移交给第一级配置器处理。 

  如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。 

  当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表 

  如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块 

  如果内存池空间足够，则取出内存 

  如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数 

  如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器 

  2）二级内存池 

  二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24......120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。

![](/home/tesla/github/learn/面试题/语言基础jpg/stl内存优化.png) 

 

1、空间配置函数allocate 

  首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。 

  2、空间释放函数deallocate 

  首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。 

  3、重新填充空闲链表refill 

  在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。 

  从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。 

  假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。 

  3、总结： 

  \1. 使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。 

  \2. 如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。 

  a. 如果链表不为空，返回第一个node，链表头改为第二个node。 

  b. 如果链表为空，使用blockAlloc请求分配node。 

  x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。 

  y. 如果内存池只有一个node的空间，直接返回给用户。 

  z. 若果如果连一个node都没有，再次向操作系统请求分配内存。 

  ①分配成功，再次进行b过程。 

  ②分配失败，循环各个自由链表，寻找空间。 

  I. 找到空间，再次进行过程b。 

  II. 找不到空间，抛出异常。 

  \3. 用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。 

  \4. 否则按照其大小找到合适的自由链表，并将其插入。

## **6、C++11**  

  **1、请问**C++11有哪些新特性**？**  

[参考网址](<https://blog.csdn.net/fx677588/article/details/70157088>)

**1、新增基于范围的for循环** 

**2、自动类型推断 auto** 

**3、匿名函数 Lambda** 

**4、后置返回类型（tailng-return-type）**

**5、显示重写(覆盖)override和final** 

**6、空指针常量 nullptr** 

**7、long long int类型** 

**8、模板的别名** 

**9、允许sizeof运算符可以再类型数据成员上使用，无需明确对象。**

**10、线程支持** 

**11、元组类型** 



  **2、请你**详细介绍一下C**++11**中的**可变参数模板**、**右值引用**和**lambda**这几个新特性。

[可变参数模板](<https://blog.csdn.net/craftsman1970/article/details/82354078>)

C++11增加了可变参数模板，可以接受可变数目，类型的参数。我们通过开发中常用的输出调试信息的例子介绍绍可变参数模板的使用方法。首先是声明可变参数模板。

![img](https://img-blog.csdn.net/20180903202221415?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYWZ0c21hbjE5NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

在模板参数定义的部分，通过typename...定义可变模板参数。三个点的含义和C语言中的可变参数定义类似，不同的是后面接着指定了可变参数列表的名称Args。

在参数定义的部分，使用可变模板参数定义的Args以相同的格式定义函数的可变参数列表。

这个参数列表可以在模板函数的实现中直接使用，这样在定义可变参数模板时就解决了可变参数函数的第二个难点。

可变参数模板的实现

可变参数模板的实现通常需要一些小技巧：递归和重载。还是先看代码。

![img](https://img-blog.csdn.net/20180903202434903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYWZ0c21hbjE5NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

代码中定义了两个重载的writeLog函数，一个只接受类型为T的参数t，另一个除了t之外，还接受可变参数rest。当使用一个参数调用writeLog的时候，实际调用上面的函数；当使用多个参数调用writeLog的时候调用下面的writeLog。

 

下面的writeLog首先使用第一个参数t调用上面的writeLog之后，使用rest递归调用writeLog（严格讲是rest中有多于一个参数的 时候）。从调用者来看，每次处理一个参数之后，使用其余的参数再次调用writeLog，直到最后调用一个参数的writeLog。

 

下面是使用writeLog的示例代码:

![img](https://img-blog.csdn.net/20180903202622865?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYWZ0c21hbjE5NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

可以任意组合参数的类型和个数，而且不需要另外提供任何信息。这样就有效地解决了可变参数函数的第一个难点。

 

更近一步

本例中一个参数的writeLog非常简单，只是简单的使用cout进行输出，如果有特殊的需求，可以继续重载这个函数。例如log输出中经常需要的时间信息，就可以这样实现：

![img](https://img-blog.csdn.net/20180903202749873?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYWZ0c21hbjE5NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

使用方法更加简单：

![img](https://img-blog.csdn.net/20180903202919482?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYWZ0c21hbjE5NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

输出结果

![img](https://img-blog.csdn.net/20180903203013248?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYWZ0c21hbjE5NzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)





**右值引用见上**　　面向对象与泛型编程



**lambad**

[详细参考网址](<https://www.cnblogs.com/DswCnblog/p/5629165.html>)

　如果代码里面存在大量的小函数，而这些函数一般只被一两处调用，那么不妨将它们重构成Lambda表达式，也就是匿名函数。作用就是当你想用一个函数，但是又不想费神去命名一个函数。 
　　该功能函数实际上在其他面向对象语言中早就存在，例如Java，Python都定义了该功能。C++中Lambda表达式格式如下：

```c
[capture](params)->ret { body};
```



　　① [capture]指定在可见域范围内lambda表达式代码内可见的参数。例如： 

- [a, &b]，前文定义的a以值方式被表达式捕获，b则是以引用的方式； 
- [this] 以值的方式捕获 this 指针。 
- [&] 以引用的方式捕获所有的外部自动变量。 
- [=] 以值的方式捕获所有的外部自动变量。 
- [] 不捕获外部的任何变量。 
  【注】：const 类型的 lambda 表达式，该类型的表达式不能改捕获(“capture”)列表中的值。 
  　　② (params)指定lambda表达式内部变量定义。 
  　　③ ->ret是返回类型，如果 lambda 代码块中包含了 return 语句，则该 lambda 表达式的返回类型由 return 语句的返回类型确定。如果没有 return 语句，则类似 void f(…) 函数。 
  　　④ {body}是Lambda表达式主题结构。 
  　　例句：

```c
auto func = [](int i){ return i+4};// 可以体会auto的好处了
cout<< func(10) << endl;           //输出为14
```



