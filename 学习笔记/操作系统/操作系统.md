#　操作系统

tar zxvf hit

make all

make all

  ./bdg-asm

  ./dbg-c

  ./rungdb





## L1，简介

一。操作系统是什么？

是计算机硬件和软件之间的一层软件

* 方便我们使用硬件　如使用显存
* 搞笑的使用硬件，如开多个终端

二。管理那些硬件？

ｃｐｕ管理　内存管理，　终端管理，磁盘管理

文件管理，　//网络管理，电源管理，多核管理

三。要学习什么？

从应用软件出发“深入操作系统”　

* 集中使用计算机接口
* 使用显示器

从应用软件出发“进入操作系统”

* 一段文字是如何写到磁盘上的

从硬件出发“设计并实现造作系统”

* 给你一个板子，配一个操作系统

８个试验

进入操作系统

能理解真是操作系统的运转

四，为什么要这样干？

我们要掌握计算机关键技术的工程师

老师所做的一切应该围绕学生开展

五，别的学生在干什么

别人已经掌握了ｓｖｄ　及其应用，我们还来扣高斯消元

高斯消元法：

ｓｖｄ：目前正应用到很多领域

斯坦福怎么学操作系统，ｃｍｕ呢？

试验１　扩展线程　实现线程调度

试验２　实现操作系统调用　将整个接口剥掉，添加

试验３　实现虚拟管理　扩展实现内存管理

试验４　扩展文件系统　扩展实现一个文件管理



##　L2，揭开钢琴的盖子

从打开电源开始？

着神秘的黑色背后发生着什么

不要总等着别人告诉你答案，尽量自己取寻找答案

　从知识和常识除法进行思索

　打开电软->计算机要开始工作了

　计算机怎么工作？



从白纸到图灵机？

说道低就是图灵机

３＋２　人看到，大脑计算，写出来

控制器读纸带　查表　控制器写出



从图灵机到通用通用图灵机

设置控制器动作，控制器状态　数据对象

　　　修改控制器

控制器增加逻辑



从图灵机到计算机

伟大的想法工程实现

伟大的发明？　冯诺依曼　存储程序思想



ＰＣ

存储器　　　　　运算器　

　　　　　　　　控制器

计算机是怎么工作的？取址执行



打开电源，计算机执行的第一句指令是什么？

计算机刚打开电源时：ｉｐ＝？

由硬件设计着决定

对于ｘ８６结构

1. x86刚开机时ｃｐｕ处于实模式
2. 开机时，ｃｓ＝ｏｘｆｆｆｆ，ｉｐ＝ｏｘ００００
3. 寻址ｏｘｆｆｆｆ０（ＲＯＭ　ＢＩＯＳ映射区）
4. 检查ＲＡＭ，键盘，显示器，软硬件磁盘
5. 将磁盘０磁道读入ｏｘ７ｃ００处（引导扇区）
6. 设置ｃｓ＝ｏｘ０７ｃｏ　ｉｐ＝ｏｘ００００

引导扇区代码：ｂｏｏｔｓｅｃｔ.s是汇编代码，严格控制内存落脚点

操作系统启动的故事

##　L3，操作系统启动

setup模块

将完成ｏｓ启动前的设置

进入保护模式

保护模式下的地址翻译和中断处理

跳转到ｓｙｓｔｅｍ模块执行

学会编写ｍａｋｅｆｉｌｅ

ｈｅａｄ.s一段在保护模式下运行的代码

通过汇编去调用ｃ语言

设置了页表之后

ｍｅｎ_init内存初始化

..... 各种数据结构初始化



１．读入内存　读入操作系统

２，初始化　　初始化一些数据



##　L4，操作系统接口

###　接口：

链接两个东西，信号转换，屏蔽细节

什么是操系统接口？

链接上层用户和操作系统软件

学会问问题

命令行是怎么回事？

ｓｙｓｔｅｍ　ｃａｌｌ

## L5，系统调用的实现

实现一个ｗｈｏａｍｉ系统调用

应用不能随意访问内存，因为内存中有重要信息，如果你可以访问不是不安全吗



用户程序调用ｗｈｏａｍｉ，一个字符串“ｌｉｚｈｉｊｕｎ”放在操作系统中

，取出来打印

不能随意调用数据，不能随意的ｊｍｐ

可以看到ｒｏｏｔ密码

可以通过显存看到别人ｗｏｒｄ里的东西



内核态　用户态



主动进入中断的方法，通过中断

int 0x80　进入

用户调用ｐｒｉｎｔｆ

ｐｒｉｎｔｆ展开成ｉｎｔｒｏｘ８０　

ｓｙｓｔｅｍ中断处理

ｓｙｓ——ｃａｌｌ——ｔａｂｌｅ查表

ｎｒ_ｗｒｉｔｅ　

ｓｙｓ——ｗｒｉｔｅ调用



##　Ｌ６，操作系统的历史，读史使人明智

###　读历使人明智

从ｉｂｓｙｓ到ｏｓ３６０

　　需要让计算机干多种事情

　　多道程序

　　作业直接额切换和调度成为核心，

　　典型代表：ｉｂｍ　ｏｓ/３６０

　　　　　　　５０００一年

从ｏｓ/360到ｍｕｌｔｉｃｓ

　　分时启动作业，使人数之间的快速切换

　　分时系统

　　代表：

　　核心是任务切换

ｍｕｌｔｉｃｓ　到unix

ｕｎｉｘ是一个简化的ｍｕｌｔｉｃｓ。核心概念杀不多，但更灵活和成功

ｕｎｉｘ到ｌｉｎｕｘ（１９９０－２０００）



掌握操作系统多进程图谱并实现它

核心思想，技术

软件工程思想



另一条历史线：

ｐｓ与ｄｏｓ

qdos与ｍｓ－ｄｏｓ

ms-dos到Ｗｉｎｄｏｗｓ

  通过文件使用计算机



ｍａｃ　ｏｓ与　ｉｏｓ时间线线



（１）掌握，实现操作系统的多进程和那个图谱；

（２）掌握，实现操作系统的文件操作视图



## L７，我们的任务

进程（多进程文件）

内存

文件（文件系统，设备文件）

##　L8，cpu管理的直观想法

管理ｃｐｕ，先要使用ｃｐｕ

　　ｃｐｕ的工作原理

　　ｃｐｕ上电以后发生了什么

看到这样的的问题，提出问题？

ｉ/o非常的慢

一条i/o指令大约是１０^6次方的计算指令

　怎么解决？

　　读写磁盘的时候来回切换，交替执行

一个ｃｐｕ上交替之心多个程序：并发

怎么做到？

　　ｐｃ进行切换　ｍｏｖ　ｐｃ　２０４

　有一个存放信息的结构ｐｃｂ

运行的程序和静态程序不一样了

引入“进程”概念：完好的刻画一个东西

运行的程序和静态程序不一样，

　　需要描述这些不一样

　　程序＋所有这些不一样－》一个概念

　　素有的不一样都表现ｐｃｂ中

进程是进行（执行）中的程序

　　进程有开始，有结束，程序没有

　　进程会走走停停，走停对程序无意义

　　进程需要记录ａｘ，ｂｘ，，程序不用

##　L9，多进程图像

多个进程使用ｃｐｕ的图像

如何充分利用ｃｐｕ呢

启动了程序就是进程，所以是多个进程推进

ｍａｉｎ中的ｆｏｒｋ创建了第一个进程

ｉｎｉｔ执行了ｓｈｅｌｌ

ｓｈｅｌｌ再启动其他进程



多进程如何组织

有一个进程在执行？

有一些进程等待执行？　ｐｃｂ队列　就绪队列

有一些进程在等待某事件？





新建态－就绪态－运行态－终止态

　　　　　　阻塞态(有事件	)





多进程组织：ｐｃｂ＋状态＋队列

多进程图像：多进程如何交替

启动磁盘读写：

交替：队列操作＋调度＋切换

进程的调度，是一个很深的话题

FIFO？　显然是公平的策略

ｐｒｉｏｒｉｔｙ 优先级应该怎么设定？　可能会使某些进程饥饿



dpl

cpl



多进程图像：多进程如何影响？

多个进程同事存在与内存会出现下面的问题？

　　进程带动内存的使用地址分离？映射表的实现

多进程图像：多进程如何合作？

想一想打印工作过程

　　应用程序提交打印任务

　　打印任务被放进打印队列

　　答应进程从队列中取出任务

　　答应进程控制打印机打印

　　从纸片到实际：生产者－消费者

　　进程同步（合理的推进顺序）



##　L10，用户级线程

将资源和指令执行分开，内存不用切

线程：保留了并发的特点

避免了进程切换代价



指令的切换，映射表的切换



多个执行序列＋一个地址空间是否使用？

一个网页浏览器，　这些线程要贡献资源吗？



两个执行序列与一个栈？

会出错，解决两个栈

栈ｔｃｂ　ｒｅｔ栈的数据

ｅｓｐ指针

### 问题？ｙｉｅｌd多线程问题用户态

还有一个问题？内核看不见浏览器的多线程，如果在调用内核时，内核中阻塞

ｃｐｕ就跳走了，，还是间断显示

##　L11，核心级线程

多处理器　　　　　　　　　多核

每个都有一个映射　　　　　公用一个映射



和用户级相比，核心级线程有啥不同

有两套栈，

内核栈，

通过中断进入内核



内核级别线程五段论

中断入口

找到ｔｃｂ

找到内核栈

完成内核栈切换

中断返回



核心级别线程,利用了多核



## L12，核心级线程实现

###　哎，

中断

创建子进程

如何执行代码	

##　L13，操作系统的那棵“树”

The mind is not a vessel that needs filling,but wood that needs igniting

ｂｕｔ 你要有材料啊！！！

思考才是王道，但是要省时才行



１，ｃｐｕ要运行

　　问题？　ｃｐｕ没有好好运转

　　形成多个程序的切换

　　形成切换，保存现场，用栈，用两个栈，

　　进行限制，用内核栈，切换内核栈

　　试验交替的打印ａｂ

###　　连续性（不断的往外扩展）

非连续性思维，四周性扩散，发散思维也是一种方式

　　运用时钟中断

　　打印ａ，时钟中断，切换，打印ｂ，时钟中断，切换

##　L14，ｃｐｕ调度策略

FIFO 先入先出

priority 短业务优先

算法怎么才能更好？

　面对客户：银行调度算法应该是：用户满意

　面对进程：ｃｐｕ调度的目标应该是　进程满意

那怎么才能让进程满意呢？　时间

　尽快结束任务：周转时间短

　用户操作尽快响应：响应时间短

　系统内耗时间少：吞吐量

总原则：系统专注与任务执行，又能合理调配，，

如何做到合理？　需要折中，和综合

　　吞吐量和响应时间之间有矛盾

　前台任务和后台任务的关注点不同

　　前台任务关注响应时间，后台分吴挂住周转时间

ｉｏ约束型任务和ｃｐｕ约束型任务有各自的特点

　　平均周转时间？

先来先出，公平

短作业优先的放方法，总周转的时间最小　

　　响应时间该怎么办

轮转调度，响应时间太长



优先级调度

前台任务，高一点

后台任务，低一点

　　故事：有一个在１９６７年提交的程序在１９７３年还没有运行

后台任务优先级升高

前台任务都用时间片

调度算法应该认识前台后台任务

#### 周转时间 用结尾时间算

轮转调度(时间片)

短作业优先 会造成饥饿

所有的任务都要有

##　L15，一个实际的ｓｃｈｅｄｕｌｅ函数厉害厉害

counter代表的优先级可以动态调整

阻塞的进程再就绪以后优先级高于非阻塞进程，为什么？

进程为什么会阻塞？ｉ/o，正是前台进程的特征

保证响应时间的界　时间片最大是２ｐ

周转时间最大是２ｎｐ

ｃｐｕ调度：一个简单的算法折中了大多数任务



##　L16，进程同步与信号量

进程合作：多进程共同完成一个任务

只发送信号还不能解决问题，

　生产者执行一段时间会执行ｓｌｅｅｐ

　消费者执行一段时间会执行ｗａｋｅｕｐ

不仅要发送一个信号我们还需要一个量来判断　是否发信号，等待了几个进程

不只是等待信号，发信号？对应睡眠和唤醒！

还应该记录一些信息

　　（１）缓冲队列，ｐ１执行，ｐ１ｓｌｅｅｐ　记录下一个进程等待

　　（２）ｐ２执行，记录下２个进程等待

　　（３）ｃ执行１次循环，发现２个进程等待，ｗａｋｅｕｐ个

信号量 sem = -1;表示有一个进程在等待

信号量sem = -2 表示有两个进程在等待



进程之间的合作就是走走听听,看信号量来左2法;`

.





##　Ｌ１７，用信号量临界保护

什么是信号量，通过对这个信号量的修改，对这个量的访问哈修改，让大家有序推进，

共同修改信号量引出的问题？

内存保护，给内存上锁，检查

临界区：一次只允许一个进程进入的内核的那一段代码

修改进去的代码，退出的时候修改代码，互斥性，

进入临界区的一个尝试－轮换法

满足互斥进入的要求

又一个尝试－标记法（如果两人相互看不见，同时留条，一看都标记了）便条



轮转加标记，两种思想，之日加轮转



1多个进程面包店算法，标号



2临界区保护  的另一类解法

用中断的方法，关中断，

什么时候不好使，多ｃｐｕ不好使



上锁的标记，如果是多层的话就是多层保护，

3.硬件原子指令法

##　L18，信号量的代码实现





##　L19，死锁处理

互相等待对方，多个进程互相等待

死锁的成因，资源是互斥的，造成环路等待

４个条件，

　　互斥使用，不可抢占，请求和保持，环路等待

死锁处理方法概述：
　　死锁预防：ｎｏ　ｓｍｏｋｉｎｇ，预防火灾

　　　　　　破坏死锁的条件

　　死锁避免：检测煤气超标到煤气超标时，自动切断电源

　　

　　死锁检测＋恢复：发现火灾时，立刻拿起灭火器



　　死锁忽略：在太阳可以对或全然不顾

　

　　死锁预防的方法例子，一次性申请所有的资源，不会占有资源再去申请



　　避免死锁：

　　　银行家算法：

　　　则称系统处于安全状态

　　　求安全序列　　（代价太大）

　　　每次来的时候计算一下，代价太大

　　死锁检测＋恢复：发现问题在处理

　　基本原因：每次申请都执行，效率低，发现问题在处理

　　不过有很多问题

　　通常采用的方法是死锁回滚(麻烦)

多数情况下采用死锁忽略

#### 死锁产生的条件环路等待

互斥使用,不可抢占,请求和保持,循环等待

死锁预防:

死锁避免:

死锁检测:

死锁忽略:

## L20,内存使用与分段

取址－执行

内存使用：将程序放到内存中，让程序执行起来

首先让程序放进内存，

重定位：修改程序中的地址（是相对地址）

　　　什么时候重定位？编译时？　载入时？

　　　编译时重定位? 速度快

一个重要的概念：交换



重定位：运行的时候重定位

　　　重定位最合适的时机－运行时重定位

进程描述符：	ｐｃｂ

有一个基址＋相对地址

内存分段处理

主程序，变量集，函数库，动态数组，堆栈

在程序员眼中的一个程序

符合用户观点：用户可独立思考，每个段（分治算法）

怎么定位具体指令：<段号，段内偏移>



进程段：基础值　长度，保护

这个表似曾相识，ｇｄｔ＋ｌｄｔ表

一个程序会有很多段,用段来分配内个程序,ldt表里记录着每个段内的东西



##　L21，内存分区与分页

映射表

将程序分成多个段：

在内存中如何找出空闲分区

运行时重定位，建立指针映射表



接下来的问题是内存怎么割

给你一个面包　与可变分区

一堆孩子来吃，怎么办？

有很多数据结构，空闲分区表。

内存选择算法，首选适配(0(1))

　　　　　　　最佳适配(O(n)内存块) 内存会特别细小

　　　　　　　最差（O(n)差别大）适配



引入分页：解决内存分区导致的内存效率问题

内存碎片造成的问题：有一个内存请求大于所有碎片

解决：将空闲分区合并，需要移动

将请求打撒？

让给面包没有谁都不想要的碎末

将面包切成片，将内存分成页

针对每个段内存请求，系统一页一页的分配给这个段

问题：需要内存紧缩吗？　不用，最大的内存浪费是多少？　４ｋ

MMU内存管理单元

物理希望分页？用户内存希望分段

段里面是段表，页里面是页表。

关联每一页ｐｃｂ

先分段，有段表，在分页，有页表，再算地址



##　L22，多级页表与块表

页表问题？页表大了

页表的放置会形成问题

每个内存都会有一个页表

大部分逻辑页号没有使用

只存放用到的页表项，　不连续

需要查找，二分仍然需要多次查询页表，(cup访问内存是比较耗时的)不好



多级页表　即页目录表（章）＋页表（节）

只用存放１６ｋ < 4m

多级页表提高空间效率，但是时间上

块表，最近进程使用的方到块表中ｔｌｂ，６４

​                                                           相比内存非常快

程序的地址访问存在局部性

空间局部性

##　L23 段页结合的实际内存管理

程序员希望用段，系统希望用页

虚拟内存　段页映射

对用户的使用是段的使用，操作系统是页的使用

用户发出段号＋偏移，虚拟地址，

分配段，建立段表，分配页，建立页表。



故事从ｆｏｒｋ开始　分配虚拟内存，建立段表

ｍｍｕ自动管理单元

父子映射表，，，，



##　L24，内存换入－请求调页

原因：虚拟内存大于物理内存

操作系统隐藏内存的使用，不用的命令由内存换入磁盘，

用的代码由磁盘换入内存

ｍｍｕ

你一实际系统的请求调页



##　L25，内存换出

有换入，就有换出

要选择那些页换出到磁盘呢？

ＦＩＦＯ 但是如果刚换入的页马上又要换出怎么办

有没有最优的淘汰方法？ＭＩＮ

最优淘汰方法不能实现，是否需要近似　ＬＲＵ



ＦＩＦＯ，页面引用序列为

评价标准：缺页次数；本实例，ｆｉｆｏ导致７次缺页

ｍｉｎ页面置换：

选最远将使用的页淘汰，是最优方案

本实例，ｍｉｎ导致５次缺页

可惜，ＭＩＮ需要知道将来发生的事，不能实现

根据过去推测未来：最近最长一段时间没有使用的页淘汰

稀疏性，局部性，低质性，



每执行一条指令都维护时间戳的表，

这个表很容易溢出，



用页面栈的方式

ＬＲＵ准确实现代价太大，需要近似实现

不去记录时间戳，将时间计数变为是和否



ｃｌｏｃｋ算法分析与改造，

如果缺页少？转的特变慢

定时清楚R位，，再来一个扫描指针

给进程分配多少页面框



置换策略有了，还需要解决一个问题？

给进程分配了多少页框

分配的多，请求调页导致内存高效利用就没有了

那内存分配的太少呢？

有一个颠簸现象

进程多,分配的页少,

cpu利用率降低,进程进一步增多,缺页率更大

分配页框调整



##　L26，i/0与显示器

向控制器发指令

ｏｕｔ指令，

中断

提供统一的视图

一段操纵外设的程序

系统调用接口

ｏｐｅｎ（“/dev/ｘｘｘ”）

ｒｅａｄ（）　　

ｗｒｉｔｅ（）　

ｃｌｏｓｅ（）

键盘指令，中断处理，磁盘命令，中断处理

根据设备对应的信息，注册函数，ｏｕｔ出去，

就行了



初始化　有光标位置

库函数ｐｒｉｎｔｆ

系统调用　ｗｒｉｔｅ

字符设备接口（ｃｒｗ——table）

ｔｔｙ设备写(tty_write)

​                       (write_q　队列)

显示器写(con_write)



## L27，键盘

让外设工作起来。

对于人：敲键盘，看结果

对于操作系统，“等着”你敲键盘，敲了就中断

所以故事从中断开始，从中断开始初始化开始

ｏｕｔｂ　ｉｎｂ　硬件知识

发出写命令

向ｃｐｕ发出中断，

读数据到内存

ｗｒｉｔｅ_q队列　显示器



##　L28，生磁盘的使用

怎么让磁盘工作起来

首先移动到制定的磁道，

磁生电，点生磁，

参数，柱面，磁头，扇区，缓存位置　　　　

　　　　ｃ　　ｈ，ｓ，　　

总线盗用技术

通过盘块号读写磁盘（一层抽象）

ｂｌｏｃｋ相邻的盘快可以快速读出

问题：如何编址？为什么编址？

磁盘访问时间＝写入控制器时间＋寻道时间＋旋转时间＋传输时间

从扇区到盘快，每次读写１ｋ；碎片，读写速度１００ｋ

每次读写１ｍ，碎片０．５ｍ，读写速度是４０/秒

用空间利用率换取读写速度

第一层抽象，从盘快到扇区

一个盘快是２个扇区

ＦＣＦＳ磁盘调度算法，

最直观，最公平的调度

一个实例：磁头开始位置＝５３

先给最直观的方法？

分析问题？改进

ｓｓｔｆ磁盘调度 最短优先

继续该实例：磁头开始位置５３

饥饿问题？

ｓｃａｎ 扫描算法

ｓｓｔｆ加中间不回折：每个请求都有处理的机会

ｃ－ｓｃａｎ磁盘调度（电梯算法）

多进程共同使用方法



进程得到盘快号，算出扇区号

用扇区号，用电梯算法

进程ｓｌｅｅｐ——ｏｎ

磁盘中断处理

##　L29，从生磁盘到文件

引入文件，对磁盘使用第三层抽象

文件的本质，字符流

文件：建立字符流到盘快集合的映射关系

映射关系的建立

映射表：　文件名，起始块，块数



问题？当文件一直增加？大于本来所给的空闲区间

怎么办？

用链式结构存放也可以实现

　问题：存取时间长



第三种文件实现结构，索引结构

ｉｎｏｄｅ

实际系统是多级索引



##　L30，文件使用的磁盘实现

直接数据块，一重间接，二重间接

伟大的文件视图

根据文件的名字/路径名，找到ｉＮｏｄｅ

根据ｉＮｏｄｅ找盘块号

根据盘快号找到网电梯队列中放

找到ｃｈｓ

磁盘寻找

ｆｃｂ

##　Ｌ30，目录树与文件系统

文件系统，抽象整个磁盘（第四层抽象）

将整个磁盘的盘快映射，

怎么完成这个映射，整个故事应该从映射开始

最该的操作目录所有文件放在一层，大杂烩

改进：一个用户一个目录

演变：引入目录树，　分治思想

引入：目录，表示一个文件集合

具体怎么编程盘快

实现目录成了关键问题

目录怎么用？

ｏｐｅｎ一个路径名

已知ａ的ｆｃｂ就知道ｉＮｏｄｅ找到

接着前面的ｘｘｘｘ

目录是怎么实现的

如何定位文件ａ

问题：更准确的说，是要干什么



问题？那么目录中应该存什么

存放目录下所有文件的ｆｃｂ吗？　如果是，解析ｍｙ要干什么

问题：有什么办法让系统效率更高

目录下存放什么：

字符串＋ｆｃｂ的指针



根目录位置固定：

根目录下存放的是目录下的子目录＋指针指向ｆｃｂ

ｆｃｂ找到每个s

磁盘需要格式化

引导块　超级块　ｉ节点位图　盘快位图　ｉ节点　数据区

０　　

##　L32，目录解析代码实现

完成全部映射下的磁盘使用

用户　　读ｔｅｓｔ。ｃ

ｏｐｅｎ（/x/test.c）目录解析找到/，读入/内容找到ｘｘ，再找到ｔｅｓｔｃ的ｉｎｏｄｅ

read(fd)　根据找到的ｆｃｂ和ｆｉｌｅ中的２０２－２１２字节找盘快７８９

写入电梯队列　ａｄｄ－ｒｅｑｕｅｓｔ（７８９）

磁盘中断　从队列中取出７８９，算出ｃｙｌ，ｈｅａｄ，ｓｅｃｔｏｒ

写磁盘控制器　ｏｕｔｐ（ｃｙｌ，ｈｅａｄ，ｓｅｃｔｏｒ）

首先将ｏｐｅｎ弄明白，解析路径

ｇｅｔ_ｄｉｒ完成真正的目录解析

开始目录解析－ｆｉｎｄ——ｅｎｔｒｙ

ｗｈｉｌｅ（ｉ　< entres）





操作系统全图

是一个管理硬件的软件

第一个管理cup 多进程图像，让cup充分忙碌

有计算指令，有指针命令，，open指令等等等有文件视图

文件视图



量大视图，多进程视图，文件视图

加上接口，，，

就是操作系统 