win32api

系统调用 unix like

java api



中断服务程序一定是操作系统编写的

操作系统传递参数寄存器-最快



存放在一个表中



软件体系结构



局部组成原理



用户级线程：

   单个线程阻塞全部阻塞

   最多占用一个cpu



大型游戏许用用户级别的线程

posix pthreads

​         建立线程

​         线程退出

​        create

win32 threads

java therads



操作系统线程



linux最初轻量级别的进程



apache 是多进程实现的

iis 是多线程实现的

快慢问题：iis快一点  

稳定性：apache稳定性好，进程独立稳定

​                线程的一条绳子上的蚂蚱

安全   ：apche高一点



浏览器战争，用户不要钱

以前

cookie，，饼干

firefox 线程  

ie 线程

chrome 进程

现在都是进程，google插件也是进程，，，，，，，





cpu调度

自愿方的调度

抢占式的调度

适合的才是最好的

看任务的作用才性 卫星上充电的不能抢

调度单位是程

调度算法的指标

一个cpu芯片两个进程一个运行1小时，一个1分钟

谁的好



一个谁先来线服务

最短剩余时间优先

抢占式的最短剩余有限服务

但是不能知道程序剩余时间是多少

预测方式：

根据程序的运行方式一种计算式的，一种平凡io方式的





时间片大小选择问题

时间片轮转 +优先级

操作系统是有良心的

系统优先级很高

前台后台　轮转法，

反馈，，，



####　多级返回队列的调度办法是现在操作系统中普遍擦用的策略



ｍｆｑ往下扔的进程是一直进行ｃｐｕ占用的



ｃｐｕ多核同构

策略内核平等你每个ｃｐｕ都是相等的，

从一个ｃｐｕ换到另一个ｃｐｕ会刷新ｃａｃｈｅ



同事访问共享数据可能造成数据的损坏

校园的魔咒

用户的魔咒



#### 直觉上对一些问题敏感的洞察

划分临界区

保护临界区



直觉：设置成变量，，，

　　　会有概率碰撞

１，互斥

２，进度条件

３，有限等待

思路拓展：只有两个进程才行

有终极方法：

　　　进临界区关中断，出来开中断

　　　原子硬件指令

　　　ｔｅｓｔａｄｄｓｅｔ



####　搞ａｃｍ的人是用逻辑分析问题可能出现的ｂｕｇ

用眼睛开代码找问题，而不是调试问题，分析问题的能力特别强



ｄｉｊｋｓｔｒａ　牛人

信号灯，信号量ｐ加ｖ减

原子操作

忙等，，，



生产者消费者问题？

流水线解决

缓冲区



读者写者问题

重要的事是写着重要



哲学家就餐问题？



句柄ｂａｎｄｌｅ

管程

自适应锁



ｄｅａｄｌｏｃｋ



条件

互斥

保持等待

不可剥夺

循环等待



没环没死锁，有环可能有死锁

死锁的解决方法，鸵鸟算法

分时，虚拟合并



声卡的虚拟合并

声卡有一个混音器，把所有的声音叠加在一起

ｓｐｏｏｌｉｎｇ 缓冲池

死锁的避免，



避免死锁：有个看门狗进程

死锁的检错和恢复技术，丢弃和遗弃，

有个策略全部杀，杀一个，

策略杀死占用资源最多的，

按照优先级高高低

问题太多了，，，，，，，，，，，，，，方法折中取舍

ｒｏｌｌｂａｃｋ回滚，要影响优先级取制定一系列的策略

